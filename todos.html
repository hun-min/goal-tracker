<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>할일 목록</title>
  <link rel="icon" href="icon-192.svg?v=2" type="image/svg+xml" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: "Inter", "Noto Sans KR", system-ui, -apple-system, sans-serif;
      background: #000;
    }
    .card-blur {
      background: rgba(15, 23, 42, 0.72);
      backdrop-filter: blur(12px);
      border: 2px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    input {
      -webkit-user-select: text;
      user-select: text;
    }
  </style>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen text-gray-100">
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect } from "https://esm.sh/react@18";
    import { createRoot } from "https://esm.sh/react-dom@18/client";
    import { Play, Pause, X } from "https://esm.sh/lucide-react@0.368.0";

    const STORAGE_KEY = "goal-tracker-data-v1";
    const DROPBOX_SYNC_PATH = "/Apps/goal-tracker/goals.json";

    function TodosPage() {
      const [goals, setGoals] = useState([]);
      const [activeTimer, setActiveTimer] = useState(null);
      const [timerSeconds, setTimerSeconds] = useState(0);
      const [timerStartTime, setTimerStartTime] = useState(null);
      const [timerMemo, setTimerMemo] = useState("");
      const [dropboxConnected, setDropboxConnected] = useState(false);
      const [editingTodoId, setEditingTodoId] = useState(null);
      const [tempMinutes, setTempMinutes] = useState({});
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [editingText, setEditingText] = useState('');
      const [selectedTodos, setSelectedTodos] = useState([]);
      const [selectionAnchor, setSelectionAnchor] = useState(null);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT') return;
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            if (historyIndex > 0) {
              const prevGoals = history[historyIndex - 1];
              setGoals(prevGoals);
              saveToStorage(prevGoals, true);
              setHistoryIndex(historyIndex - 1);
            }
          } else if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
            e.preventDefault();
            if (historyIndex < history.length - 1) {
              const nextGoals = history[historyIndex + 1];
              setGoals(nextGoals);
              saveToStorage(nextGoals, true);
              setHistoryIndex(historyIndex + 1);
            }
          } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            const allTodos = [];
            goals.forEach(goal => {
              allTodos.push({ type: 'goal', id: `goal-${goal.id}`, goal });
              if (goal.todos && goal.todos.length > 0) {
                goal.todos.forEach(todo => {
                  allTodos.push({ type: 'todo', id: todo.id, goal, todo });
                });
              }
            });
            
            const currentIndex = allTodos.findIndex(item => 
              item.type === 'goal' ? editingTodoId === item.id : editingTodoId === item.id
            );
            
            if (currentIndex !== -1) {
              e.preventDefault();
              const nextIndex = e.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
              if (nextIndex >= 0 && nextIndex < allTodos.length) {
                const nextItem = allTodos[nextIndex];
                if (e.shiftKey) {
                  if (!selectionAnchor) {
                    setSelectionAnchor(currentIndex);
                  }
                  const start = Math.min(selectionAnchor || currentIndex, nextIndex);
                  const end = Math.max(selectionAnchor || currentIndex, nextIndex);
                  const selected = allTodos.slice(start, end + 1).filter(item => item.type === 'todo').map(item => item.todo.id);
                  setSelectedTodos(selected);
                } else {
                  setSelectionAnchor(null);
                  setSelectedTodos([]);
                }
                setEditingTodoId(nextItem.type === 'goal' ? nextItem.id : nextItem.id);
                if (nextItem.type === 'todo') {
                  setEditingText(nextItem.todo.text);
                } else {
                  setEditingText(nextItem.goal.name);
                }
              }
            }
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [editingTodoId, goals, history, historyIndex]);

      useEffect(() => {
        const loadData = async () => {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed?.goals) {
              console.log('Loaded goals:', parsed.goals);
              setGoals(parsed.goals);
            }
          }

          if (window.location.protocol === 'file:') return;

          try {
            const statusRes = await fetch('/api/dropbox/status');
            const statusData = await statusRes.json();
            setDropboxConnected(statusData.connected);

            if (statusData.connected) {
              const res = await fetch('/api/dropbox/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'pull' })
              });
              const response = await res.json();
              const dropboxData = response.contents ? JSON.parse(response.contents) : null;
              if (dropboxData?.goals) setGoals(dropboxData.goals);
            }
          } catch (err) {}
        };

        loadData();

        const saved = localStorage.getItem('timer-state');
        if (saved) {
          const { activeTimer: savedTimer, timerStartTime: savedStart } = JSON.parse(saved);
          if (savedTimer && savedStart) {
            const elapsed = Math.floor((Date.now() - savedStart) / 1000);
            setActiveTimer(savedTimer);
            setTimerSeconds(elapsed);
            setTimerStartTime(savedStart);
          }
        }
      }, []);

      useEffect(() => {
        if (activeTimer === null || !timerStartTime) return;
        const interval = setInterval(() => {
          if (!document.hidden) {
            setTimerSeconds(Math.floor((Date.now() - timerStartTime) / 1000));
          }
        }, 1000);
        return () => clearInterval(interval);
      }, [activeTimer, timerStartTime]);

      const saveToStorage = (newGoals, skipHistory = false) => {
        const payload = JSON.stringify({ goals: newGoals, savedAt: new Date().toISOString() });
        localStorage.setItem(STORAGE_KEY, payload);
        
        if (!skipHistory) {
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(newGoals);
          if (newHistory.length > 50) newHistory.shift();
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
        }
        
        if (dropboxConnected) {
          setTimeout(async () => {
            try {
              await fetch('/api/dropbox/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'push', contents: payload })
              });
            } catch (err) {}
          }, 1000);
        }
      };

      const startTimer = (goalId, todoText = "") => {
        const now = Date.now();
        setActiveTimer(goalId);
        setTimerSeconds(0);
        setTimerStartTime(now);
        setTimerMemo(todoText);
        localStorage.setItem('timer-state', JSON.stringify({
          activeTimer: goalId,
          timerStartTime: now
        }));
      };

      const stopTimer = (goalId) => {
        if (activeTimer === goalId && timerSeconds > 0) {
          const endTime = new Date();
          const startTime = new Date(timerStartTime);
          const newGoals = goals.map((goal) => {
            if (goal.id === goalId) {
              return {
                ...goal,
                totalSeconds: goal.totalSeconds + timerSeconds,
                logs: [
                  {
                    date: new Date().toLocaleDateString("ko-KR"),
                    seconds: timerSeconds,
                    memo: timerMemo || "",
                    startTime: `${String(startTime.getHours()).padStart(2, '0')}:${String(startTime.getMinutes()).padStart(2, '0')}`,
                    endTime: `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`,
                    fromTodo: true
                  },
                  ...goal.logs
                ]
              };
            }
            return goal;
          });
          setGoals(newGoals);
          saveToStorage(newGoals);
        }
        setActiveTimer(null);
        setTimerSeconds(0);
        setTimerStartTime(null);
        setTimerMemo("");
        localStorage.removeItem('timer-state');
      };

      const cancelTimer = (goalId) => {
        if (activeTimer === goalId) {
          setActiveTimer(null);
          setTimerSeconds(0);
          setTimerStartTime(null);
          setTimerMemo("");
          localStorage.removeItem('timer-state');
        }
      };

      const toggleTodo = (goalId, todoId) => {
        const newGoals = goals.map((g) => {
          if (g.id === goalId) {
            const todo = g.todos.find(t => t.id === todoId);
            if (!todo.done) {
              const isTodoTimer = activeTimer === goalId && timerMemo === todo.text;
              const actualSeconds = isTodoTimer ? timerSeconds : (todo.estimatedMinutes || 0) * 60;
              return {
                ...g,
                todos: g.todos.filter(t => t.id !== todoId),
                logs: [{
                  date: new Date().toLocaleDateString("ko-KR"),
                  seconds: actualSeconds,
                  memo: todo.text,
                  fromTodo: true,
                  estimated: todo.estimatedMinutes
                }, ...g.logs]
              };
            }
            return { ...g, todos: g.todos.map(t => t.id === todoId ? { ...t, done: !t.done } : t) };
          }
          return g;
        });
        setGoals(newGoals);
        saveToStorage(newGoals);
      };

      const updateTodo = (goalId, todoId, text, estimatedMinutes) => {
        const newGoals = goals.map((g) => 
          g.id === goalId 
            ? { ...g, todos: g.todos.map(t => t.id === todoId ? { ...t, text, estimatedMinutes } : t) }
            : g
        );
        setGoals(newGoals);
        saveToStorage(newGoals);
      };

      const updateIndent = (goalId, todoId, delta) => {
        const newGoals = goals.map((g) => {
          if (g.id === goalId) {
            return {
              ...g,
              todos: g.todos.map(t => {
                if (t.id === todoId) {
                  const newIndent = Math.max(0, Math.min(3, (t.indent || 0) + delta));
                  return { ...t, indent: newIndent };
                }
                return t;
              })
            };
          }
          return g;
        });
        setGoals(newGoals);
        saveToStorage(newGoals);
      };

      const formatTime = (seconds) => {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      };

      const allTodos = [];
      goals.forEach(goal => {
        allTodos.push({ type: 'goal', goal });
        if (goal.todos && goal.todos.length > 0) {
          goal.todos.forEach(todo => {
            allTodos.push({ type: 'todo', goal, todo });
          });
        }
      });

      return (
        <div className="min-h-screen bg-black p-4">
          <div className="max-w-4xl mx-auto">
            <div className="flex items-center justify-between mb-4">
              <h1 className="text-xl font-bold text-white">✓ 할일 목록</h1>
              <a href="index.html" className="px-3 py-1 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm">
                메인으로
              </a>
            </div>

            {allTodos.length === 0 ? (
              <div className="text-center py-12 text-gray-400 text-sm">
                할일이 없습니다
              </div>
            ) : (
              <div>
                  {allTodos.map((item, idx) => {
                    if (item.type === 'goal') {
                      const goal = item.goal;
                      const isTimerActive = activeTimer === goal.id && !timerMemo;
                      const isEditingGoal = editingTodoId === `goal-${goal.id}`;
                      return (
                        <div 
                          key={`goal-${goal.id}`} 
                          className="flex items-center text-sm md:hover:bg-gray-800/20 rounded px-1 relative cursor-pointer" 
                          style={{ height: '32px' }}
                          onClick={() => setEditingTodoId(`goal-${goal.id}`)}
                        >
                          <input 
                            type="checkbox" 
                            checked={!!goal.completedAt} 
                            onChange={() => {}} 
                            className="w-3.5 h-3.5 mr-2 flex-shrink-0" 
                            disabled 
                            onClick={(e) => e.stopPropagation()}
                          />
                          <div className={`flex-1 py-2 font-medium ${goal.completedAt ? 'line-through text-gray-500' : 'text-gray-200'}`}>
                            {goal.name}
                          </div>
                          {isEditingGoal && (
                            <div className="absolute top-0 bottom-0 flex items-center bg-gray-900" style={{ left: '22px', right: '80px' }} onClick={(e) => e.stopPropagation()}>
                              <input
                                type="text"
                                defaultValue={goal.name}
                                autoFocus
                                onKeyDown={(e) => {
                                  if (e.key === 'Enter') {
                                    e.preventDefault();
                                    const text = e.target.value.trim();
                                    if (text) {
                                      const newGoals = goals.map(g => g.id === goal.id ? { ...g, name: text } : g);
                                      setGoals(newGoals);
                                      saveToStorage(newGoals);
                                    }
                                    setEditingTodoId(null);
                                  } else if (e.key === 'Escape') {
                                    setEditingTodoId(null);
                                  }
                                }}
                                className="flex-1 px-1 py-1 bg-gray-700 text-gray-100 rounded focus:outline-none border-0 text-sm"
                              />
                            </div>
                          )}
                          <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                            {isTimerActive && (
                              <>
                                <span className="text-cyan-300 text-xs font-mono">{formatTime(timerSeconds)}</span>
                                <button onClick={() => cancelTimer(goal.id)} className="px-1.5 py-0.5 bg-red-500 hover:bg-red-400 text-white rounded text-xs">
                                  <X size={12} />
                                </button>
                              </>
                            )}
                            <button
                              onClick={() => isTimerActive ? stopTimer(goal.id) : startTimer(goal.id)}
                              className={`px-1.5 py-0.5 rounded text-xs ${isTimerActive ? 'bg-rose-500 hover:bg-rose-400' : 'bg-green-500 hover:bg-green-400'} text-white`}
                            >
                              {isTimerActive ? <Pause size={12} /> : <Play size={12} />}
                            </button>
                          </div>
                        </div>
                      );
                    } else {
                      const { goal, todo } = item;
                      const isTodoTimerActive = activeTimer === goal.id && timerMemo === todo.text;
                      const isEditing = editingTodoId === todo.id;
                      return (
                        <div
                          key={`todo-${todo.id}`}
                          className={`flex items-center text-sm md:hover:bg-gray-800/20 rounded px-1 relative cursor-pointer ${selectedTodos.includes(todo.id) ? 'bg-blue-900/40' : ''}`}
                          style={{ marginLeft: `${((todo.indent || 0) + 1) * 20}px`, height: '32px' }}
                          onClick={() => {
                            if (editingTodoId && editingTodoId !== todo.id) {
                              const editingGoal = goals.find(g => g.todos?.some(t => t.id === editingTodoId));
                              if (editingGoal) {
                                const editingTodo = editingGoal.todos.find(t => t.id === editingTodoId);
                                const textInput = document.querySelector('input[type="text"]');
                                const text = textInput?.value.trim();
                                const minsValue = tempMinutes[editingTodoId] ?? editingTodo.estimatedMinutes;
                                const mins = minsValue ? parseInt(minsValue) : undefined;
                                if (text) {
                                  updateTodo(editingGoal.id, editingTodoId, text, mins);
                                }
                                setTempMinutes({...tempMinutes, [editingTodoId]: undefined});
                              }
                            }
                            setEditingTodoId(todo.id);
                            setEditingText(todo.text);
                          }}
                        >
                            <input
                              type="checkbox"
                              checked={todo.done}
                              onChange={() => toggleTodo(goal.id, todo.id)}
                              className="w-3.5 h-3.5 mr-2 flex-shrink-0"
                              onClick={(e) => e.stopPropagation()}
                            />

                            <div className={`flex-1 mr-2 py-2 text-sm ${todo.done ? 'line-through text-gray-500' : 'text-gray-300'}`}>
                              {todo.estimatedMinutes && (
                                <span className="text-blue-400 text-xs mr-1">{todo.estimatedMinutes}분</span>
                              )}
                              {todo.text || ' '}
                            </div>

                            {isEditing && (
                              <div className="absolute top-0 bottom-0 flex items-center bg-gray-900" style={{ left: '22px', right: '80px' }} onClick={(e) => e.stopPropagation()}>
                                <input
                                  type="text"
                                  value={editingText}
                                  onChange={(e) => setEditingText(e.target.value)}
                                  autoFocus
                                  onKeyDown={(e) => {
                                    if (e.key === 'Backspace') {
                                      const cursorPos = e.target.selectionStart;
                                      if (cursorPos === 0) {
                                        e.preventDefault();
                                        const allTodos = [];
                                        goals.forEach(g => {
                                          allTodos.push({ type: 'goal', id: `goal-${g.id}`, goal: g });
                                          if (g.todos && g.todos.length > 0) {
                                            g.todos.forEach(t => {
                                              allTodos.push({ type: 'todo', id: t.id, goal: g, todo: t });
                                            });
                                          }
                                        });
                                        const currentIndex = allTodos.findIndex(item => item.id === todo.id);
                                        const prevItem = currentIndex > 0 ? allTodos[currentIndex - 1] : null;
                                        
                                        if (prevItem && prevItem.type === 'todo' && prevItem.goal.id === goal.id) {
                                          const prevText = prevItem.todo.text;
                                          const currentText = editingText;
                                          const cursorPosition = prevText.length;
                                          const newGoals = goals.map((g) => {
                                            if (g.id === goal.id) {
                                              return {
                                                ...g,
                                                todos: g.todos.map(t => {
                                                  if (t.id === prevItem.todo.id) {
                                                    return { ...t, text: prevText + currentText };
                                                  }
                                                  return t;
                                                }).filter(t => t.id !== todo.id)
                                              };
                                            }
                                            return g;
                                          });
                                          setGoals(newGoals);
                                          saveToStorage(newGoals);
                                          setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                          const mergedText = prevText + currentText;
                                          setEditingTodoId(prevItem.id);
                                          setEditingText(mergedText);
                                          setTimeout(() => {
                                            const input = document.querySelector('input[type="text"]');
                                            if (input) {
                                              input.focus();
                                              input.setSelectionRange(cursorPosition, cursorPosition);
                                            }
                                          }, 0);
                                        } else if (editingText === '') {
                                          const newGoals = goals.map((g) => {
                                            if (g.id === goal.id) {
                                              return { ...g, todos: g.todos.filter(t => t.id !== todo.id) };
                                            }
                                            return g;
                                          });
                                          setGoals(newGoals);
                                          saveToStorage(newGoals);
                                          setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                          if (prevItem) {
                                            setEditingTodoId(prevItem.id);
                                          } else {
                                            setEditingTodoId(null);
                                          }
                                        }
                                      }
                                    } else if (e.key === 'Enter') {
                                      e.preventDefault();
                                      const text = editingText.trim();
                                      const minsValue = tempMinutes[todo.id] ?? todo.estimatedMinutes;
                                      const mins = minsValue ? parseInt(minsValue) : undefined;
                                      const newTodoId = Date.now();
                                      const newGoals = goals.map((g) => {
                                        if (g.id === goal.id) {
                                          const todoIndex = g.todos.findIndex(t => t.id === todo.id);
                                          const updatedTodos = [...g.todos];
                                          if (text) {
                                            updatedTodos[todoIndex] = { ...todo, text, estimatedMinutes: mins };
                                          }
                                          const newTodo = { id: newTodoId, text: '', done: false, indent: todo.indent || 0 };
                                          updatedTodos.splice(todoIndex + 1, 0, newTodo);
                                          return { ...g, todos: updatedTodos };
                                        }
                                        return g;
                                      });
                                      setGoals(newGoals);
                                      saveToStorage(newGoals);
                                      setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                      setEditingTodoId(newTodoId);
                                      setEditingText('');
                                    } else if (e.key === 'd' && e.ctrlKey) {
                                      e.preventDefault();
                                      const allTodos = [];
                                      goals.forEach(g => {
                                        allTodos.push({ type: 'goal', id: `goal-${g.id}`, goal: g });
                                        if (g.todos && g.todos.length > 0) {
                                          g.todos.forEach(t => {
                                            allTodos.push({ type: 'todo', id: t.id, goal: g, todo: t });
                                          });
                                        }
                                      });
                                      const currentIndex = allTodos.findIndex(item => item.id === todo.id);
                                      const nextItem = currentIndex < allTodos.length - 1 ? allTodos[currentIndex + 1] : (currentIndex > 0 ? allTodos[currentIndex - 1] : null);
                                      
                                      const newGoals = goals.map((g) => {
                                        if (g.id === goal.id) {
                                          return { ...g, todos: g.todos.filter(t => t.id !== todo.id) };
                                        }
                                        return g;
                                      });
                                      setGoals(newGoals);
                                      saveToStorage(newGoals);
                                      setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                      if (nextItem) {
                                        setEditingTodoId(nextItem.id);
                                      } else {
                                        setEditingTodoId(null);
                                      }
                                    } else if (e.key === 'Delete' && e.target.value === '') {
                                      e.preventDefault();
                                      const allTodos = [];
                                      goals.forEach(g => {
                                        allTodos.push({ type: 'goal', id: `goal-${g.id}`, goal: g });
                                        if (g.todos && g.todos.length > 0) {
                                          g.todos.forEach(t => {
                                            allTodos.push({ type: 'todo', id: t.id, goal: g, todo: t });
                                          });
                                        }
                                      });
                                      const currentIndex = allTodos.findIndex(item => item.id === todo.id);
                                      const nextItem = currentIndex < allTodos.length - 1 ? allTodos[currentIndex + 1] : (currentIndex > 0 ? allTodos[currentIndex - 1] : null);
                                      
                                      const newGoals = goals.map((g) => {
                                        if (g.id === goal.id) {
                                          return { ...g, todos: g.todos.filter(t => t.id !== todo.id) };
                                        }
                                        return g;
                                      });
                                      setGoals(newGoals);
                                      saveToStorage(newGoals);
                                      setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                      if (nextItem) {
                                        setEditingTodoId(nextItem.id);
                                      } else {
                                        setEditingTodoId(null);
                                      }
                                    } else if (e.key === 'Delete') {
                                      const cursorPos = e.target.selectionStart;
                                      const textLength = editingText.length;
                                      if (cursorPos === textLength) {
                                        e.preventDefault();
                                        const allTodos = [];
                                        goals.forEach(g => {
                                          allTodos.push({ type: 'goal', id: `goal-${g.id}`, goal: g });
                                          if (g.todos && g.todos.length > 0) {
                                            g.todos.forEach(t => {
                                              allTodos.push({ type: 'todo', id: t.id, goal: g, todo: t });
                                            });
                                          }
                                        });
                                        const currentIndex = allTodos.findIndex(item => item.id === todo.id);
                                        const nextItem = currentIndex < allTodos.length - 1 ? allTodos[currentIndex + 1] : null;
                                        
                                        if (nextItem && nextItem.type === 'todo' && nextItem.goal.id === goal.id) {
                                          const currentText = editingText;
                                          const cursorPosition = currentText.length;
                                          const nextText = nextItem.todo.text;
                                          const newGoals = goals.map((g) => {
                                            if (g.id === goal.id) {
                                              return {
                                                ...g,
                                                todos: g.todos.map(t => {
                                                  if (t.id === todo.id) {
                                                    return { ...t, text: currentText + nextText };
                                                  }
                                                  return t;
                                                }).filter(t => t.id !== nextItem.todo.id)
                                              };
                                            }
                                            return g;
                                          });
                                          setGoals(newGoals);
                                          saveToStorage(newGoals);
                                          const mergedText = currentText + nextText;
                                          setEditingTodoId(todo.id);
                                          setEditingText(mergedText);
                                          setTimeout(() => {
                                            const input = document.querySelector('input[type="text"]');
                                            if (input) {
                                              input.focus();
                                              input.setSelectionRange(cursorPosition, cursorPosition);
                                            }
                                          }, 0);
                                        }
                                      }
                                    } else if (e.key === 'Escape') {
                                      setEditingTodoId(null);
                                      setTempMinutes({...tempMinutes, [todo.id]: undefined});
                                    } else if (e.key === 'Tab') {
                                      e.preventDefault();
                                      updateIndent(goal.id, todo.id, e.shiftKey ? -1 : 1);
                                    }
                                  }}
                                  className="flex-1 mr-2 px-1 py-1 bg-gray-700 text-gray-100 rounded focus:outline-none border-0 text-sm"
                                />
                                <input
                                  type="number"
                                  value={tempMinutes[todo.id] ?? todo.estimatedMinutes ?? ''}
                                  placeholder="분"
                                  onChange={(e) => setTempMinutes({...tempMinutes, [todo.id]: e.target.value})}
                                  className="w-16 mr-2 px-1 py-1 bg-gray-700 text-gray-100 rounded focus:outline-none border-0 text-sm"
                                />
                                <button
                                  onClick={() => updateIndent(goal.id, todo.id, -1)}
                                  className="px-2 py-0.5 mr-1 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'<'}
                                </button>
                                <button
                                  onClick={() => updateIndent(goal.id, todo.id, 1)}
                                  className="px-2 py-0.5 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'>'}
                                </button>
                              </div>
                            )}

                            <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                              {isTodoTimerActive && (
                                <>
                                  <span className="text-cyan-300 text-xs font-mono">
                                    {formatTime(timerSeconds)}
                                  </span>
                                  <button
                                    onClick={() => cancelTimer(goal.id)}
                                    className="px-1.5 py-0.5 bg-red-500 hover:bg-red-400 text-white rounded text-xs"
                                  >
                                    <X size={12} />
                                  </button>
                                </>
                              )}
                              <button
                                onClick={() => isTodoTimerActive ? stopTimer(goal.id) : startTimer(goal.id, todo.text)}
                                className={`px-1.5 py-0.5 rounded text-xs ${
                                  isTodoTimerActive
                                    ? 'bg-rose-500 hover:bg-rose-400'
                                    : 'bg-green-500 hover:bg-green-400'
                                } text-white`}
                              >
                                {isTodoTimerActive ? <Pause size={12} /> : <Play size={12} />}
                              </button>
                            </div>
                          </div>
                        );
                    }
                  })}
              </div>
            )}
          </div>
        </div>
      );
    }

    createRoot(document.getElementById("root")).render(<TodosPage />);
  </script>
</body>
</html>
