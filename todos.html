<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>할일 목록</title>
  <link rel="icon" href="icon-192.svg?v=2" type="image/svg+xml" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: "Inter", "Noto Sans KR", system-ui, -apple-system, sans-serif;
      background: #000;
    }
    .card-blur {
      background: rgba(15, 23, 42, 0.72);
      backdrop-filter: blur(12px);
      border: 2px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    * {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    input, textarea, [contenteditable] {
      -webkit-user-select: text;
      user-select: text;
    }
    textarea {
      resize: none;
      overflow: hidden;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }
    [contenteditable] {
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .flex-1 {
      word-break: break-word;
      overflow-wrap: break-word;
    }
  </style>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen text-gray-100">
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useEffect } from "https://esm.sh/react@18";
    import { createRoot } from "https://esm.sh/react-dom@18/client";
    import { Play, Pause, X } from "https://esm.sh/lucide-react@0.368.0";

    const STORAGE_KEY = "goal-tracker-data-v1";
    const DROPBOX_SYNC_PATH = "/Apps/goal-tracker/goals.json";

    function TodosPage() {
      const [goals, setGoals] = useState([]);
      const [activeTimer, setActiveTimer] = useState(null);
      const [timerSeconds, setTimerSeconds] = useState(0);
      const [timerStartTime, setTimerStartTime] = useState(null);
      const [timerMemo, setTimerMemo] = useState("");
      const [dropboxConnected, setDropboxConnected] = useState(false);
      const [editingTodoId, setEditingTodoId] = useState(null);
      const [tempMinutes, setTempMinutes] = useState({});
      const [history, setHistory] = useState([]);
      const [historyIndex, setHistoryIndex] = useState(-1);
      const [editingText, setEditingText] = useState('');
      const [selectedTodos, setSelectedTodos] = useState([]);
      const [selectionAnchor, setSelectionAnchor] = useState(null);
      const [sections, setSections] = useState([]);
      const [draggedGoal, setDraggedGoal] = useState(null);
      const [activeSectionId, setActiveSectionId] = useState(null);

      useEffect(() => {
        const handleBeforeUnload = () => {
          if (editingTodoId && editingTodoId.startsWith('goal-')) {
            const goalId = parseInt(editingTodoId.replace('goal-', ''));
            const goal = goals.find(g => g.id === goalId);
            if (goal) {
              updateGoal(goal.id, editingText, goal.estimatedMinutes, goal.indent);
            }
          }
        };
        window.addEventListener('beforeunload', handleBeforeUnload);
        return () => window.removeEventListener('beforeunload', handleBeforeUnload);
      }, [editingTodoId, editingText, goals]);

      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.target.tagName === 'INPUT') return;
          if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            if (historyIndex > 0) {
              const prevGoals = history[historyIndex - 1];
              setHistoryIndex(historyIndex - 1);
              setGoals(prevGoals);
              saveToStorage(prevGoals, sections, true);
            }
          } else if (((e.ctrlKey || e.metaKey) && e.key === 'y') || ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
            e.preventDefault();
            if (historyIndex < history.length - 1) {
              const nextGoals = history[historyIndex + 1];
              setHistoryIndex(historyIndex + 1);
              setGoals(nextGoals);
              saveToStorage(nextGoals, sections, true);
            }
          } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            const allTodos = [];
            goals.forEach(goal => {
              allTodos.push({ type: 'goal', id: `goal-${goal.id}`, goal });
              if (goal.todos && goal.todos.length > 0) {
                goal.todos.forEach(todo => {
                  allTodos.push({ type: 'todo', id: todo.id, goal, todo });
                });
              }
            });
            
            const currentIndex = allTodos.findIndex(item => 
              item.type === 'goal' ? editingTodoId === item.id : editingTodoId === item.id
            );
            
            if (currentIndex !== -1) {
              e.preventDefault();
              const nextIndex = e.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
              if (nextIndex >= 0 && nextIndex < allTodos.length) {
                const nextItem = allTodos[nextIndex];
                if (e.shiftKey) {
                  if (!selectionAnchor) {
                    setSelectionAnchor(currentIndex);
                  }
                  const start = Math.min(selectionAnchor || currentIndex, nextIndex);
                  const end = Math.max(selectionAnchor || currentIndex, nextIndex);
                  const selected = allTodos.slice(start, end + 1).filter(item => item.type === 'todo').map(item => item.todo.id);
                  setSelectedTodos(selected);
                } else {
                  setSelectionAnchor(null);
                  setSelectedTodos([]);
                }
                setEditingTodoId(nextItem.type === 'goal' ? nextItem.id : nextItem.id);
                if (nextItem.type === 'todo') {
                  setEditingText(nextItem.todo.text);
                } else {
                  setEditingText(nextItem.goal.name);
                }
              }
            }
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [editingTodoId, goals, history, historyIndex]);

      useEffect(() => {
        const loadData = async () => {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            const parsed = JSON.parse(stored);
            if (parsed?.goals) {
              setGoals(parsed.goals);
            }
            if (parsed?.sections) {
              setSections(parsed.sections);
            }
          }

          if (window.location.protocol === 'file:') return;

          try {
            const statusRes = await fetch('/api/dropbox/status');
            const statusData = await statusRes.json();
            setDropboxConnected(statusData.connected);

            if (statusData.connected) {
              const res = await fetch('/api/dropbox/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'pull' })
              });
              const response = await res.json();
              const dropboxData = response.contents ? JSON.parse(response.contents) : null;
              if (dropboxData?.goals) setGoals(dropboxData.goals);
              if (dropboxData?.sections) setSections(dropboxData.sections);
            }
          } catch (err) {}
        };

        loadData();

        const saved = localStorage.getItem('timer-state');
        if (saved) {
          const { activeTimer: savedTimer, timerStartTime: savedStart } = JSON.parse(saved);
          if (savedTimer && savedStart) {
            const elapsed = Math.floor((Date.now() - savedStart) / 1000);
            setActiveTimer(savedTimer);
            setTimerSeconds(elapsed);
            setTimerStartTime(savedStart);
          }
        }
      }, []);

      useEffect(() => {
        if (activeTimer === null || !timerStartTime) return;
        const interval = setInterval(() => {
          if (!document.hidden) {
            setTimerSeconds(Math.floor((Date.now() - timerStartTime) / 1000));
          }
        }, 1000);
        return () => clearInterval(interval);
      }, [activeTimer, timerStartTime]);

      const saveToStorage = (newGoals, newSections = sections, skipHistory = false) => {
        const payload = JSON.stringify({ goals: newGoals, sections: newSections, savedAt: new Date().toISOString() });
        localStorage.setItem(STORAGE_KEY, payload);
        
        if (!skipHistory) {
          const newHistory = history.slice(0, historyIndex + 1);
          newHistory.push(newGoals);
          if (newHistory.length > 50) newHistory.shift();
          setHistory(newHistory);
          setHistoryIndex(newHistory.length - 1);
        }
        
        if (dropboxConnected) {
          setTimeout(async () => {
            try {
              await fetch('/api/dropbox/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'push', contents: payload })
              });
            } catch (err) {}
          }, 1000);
        }
      };

      const startTimer = async (goalId, todoText = "") => {
        const now = Date.now();
        const goal = goals.find(g => g.id === goalId);
        
        const currentSeconds = goal?.totalSeconds || 0;
        const currentH = Math.floor(currentSeconds / 3600);
        const currentM = Math.floor((currentSeconds % 3600) / 60);
        const currentStr = currentH > 0 ? `${currentH}시간 ${currentM}분` : `${currentM}분`;
        
        const targetSeconds = (goal?.estimatedMinutes || 0) * 60;
        const targetH = Math.floor(targetSeconds / 3600);
        const targetM = Math.floor((targetSeconds % 3600) / 60);
        const targetStr = targetH > 0 ? `${targetH}시간 ${targetM}분` : `${targetM}분`;
        
        const progress = targetSeconds > 0 ? Math.min((currentSeconds / targetSeconds) * 100, 100).toFixed(0) : 0;
        
        let description = todoText ? `${goal?.name} - ${todoText}` : (goal?.name || 'Goal Tracker');
        const togglFormat = localStorage.getItem('toggl_format') || '';
        if (togglFormat) {
          const formatted = togglFormat
            .replace('{current}', currentStr)
            .replace('{target}', targetStr)
            .replace('{progress}', progress);
          description += ` ${formatted}`;
        }
        
        const togglApiToken = localStorage.getItem('toggl_api_token') || '';
        let entryId = null;
        if (togglApiToken) {
          try {
            const response = await fetch('/api/toggl/start', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ apiToken: togglApiToken, description, projectName: null })
            });
            if (response.ok) {
              const data = await response.json();
              entryId = data.entryId;
            }
          } catch (err) {}
        }
        
        setActiveTimer(goalId);
        setTimerSeconds(0);
        setTimerStartTime(now);
        setTimerMemo(todoText);
        localStorage.setItem('timer-state', JSON.stringify({
          activeTimer: goalId,
          timerStartTime: now,
          togglEntryId: entryId
        }));
      };

      const stopTimer = async (goalId) => {
        const saved = localStorage.getItem('timer-state');
        if (saved) {
          const { togglEntryId } = JSON.parse(saved);
          if (togglEntryId) {
            const togglApiToken = localStorage.getItem('toggl_api_token') || '';
            if (togglApiToken) {
              try {
                await fetch('/api/toggl/stop', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ apiToken: togglApiToken, entryId: togglEntryId })
                });
              } catch (err) {}
            }
          }
        }
        
        if (activeTimer === goalId && timerSeconds > 0) {
          const endTime = new Date();
          const startTime = new Date(timerStartTime);
          const newGoals = goals.map((goal) => {
            if (goal.id === goalId) {
              return {
                ...goal,
                totalSeconds: goal.totalSeconds + timerSeconds,
                logs: [
                  {
                    date: new Date().toLocaleDateString("ko-KR"),
                    seconds: timerSeconds,
                    memo: timerMemo || "",
                    startTime: `${String(startTime.getHours()).padStart(2, '0')}:${String(startTime.getMinutes()).padStart(2, '0')}`,
                    endTime: `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`,
                    fromTodo: true
                  },
                  ...goal.logs
                ]
              };
            }
            return goal;
          });
          setGoals(newGoals);
          saveToStorage(newGoals, sections);
        }
        setActiveTimer(null);
        setTimerSeconds(0);
        setTimerStartTime(null);
        setTimerMemo("");
        localStorage.removeItem('timer-state');
      };

      const cancelTimer = (goalId) => {
        if (activeTimer === goalId) {
          setActiveTimer(null);
          setTimerSeconds(0);
          setTimerStartTime(null);
          setTimerMemo("");
          localStorage.removeItem('timer-state');
        }
      };

      const toggleTodo = (goalId, todoId) => {
        const newGoals = goals.map((g) => {
          if (g.id === goalId) {
            return { ...g, todos: g.todos.map(t => t.id === todoId ? { ...t, done: !t.done } : t) };
          }
          return g;
        });
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
      };

      const toggleGoal = (goalId) => {
        const newGoals = goals.map((g) => {
          if (g.id === goalId) {
            return { ...g, completedAt: g.completedAt ? null : new Date().toISOString() };
          }
          return g;
        });
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
      };

      const updateTodo = (goalId, todoId, text, estimatedMinutes, indent) => {
        const newGoals = goals.map((g) => 
          g.id === goalId 
            ? { ...g, todos: g.todos.map(t => t.id === todoId ? { ...t, text, estimatedMinutes, indent } : t) }
            : g
        );
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
      };

      const updateGoal = (goalId, name, estimatedMinutes, indent) => {
        const newGoals = goals.map((g) => 
          g.id === goalId ? { ...g, name, estimatedMinutes, indent } : g
        );
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
      };

      const addGoal = (sectionId = null, afterGoalId = null, inheritIndent = 0) => {
        const newGoal = {
          id: Date.now(),
          name: '',
          totalSeconds: 0,
          logs: [],
          todos: [],
          sectionId,
          indent: inheritIndent
        };
        let newGoals;
        if (afterGoalId) {
          const index = goals.findIndex(g => g.id === afterGoalId);
          newGoals = [...goals.slice(0, index + 1), newGoal, ...goals.slice(index + 1)];
        } else {
          newGoals = [...goals, newGoal];
        }
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
        setEditingTodoId(`goal-${newGoal.id}`);
        setEditingText('');
      };

      const updateIndent = (goalId, todoId, delta) => {
        const newGoals = goals.map((g) => {
          if (g.id === goalId) {
            return {
              ...g,
              todos: g.todos.map(t => {
                if (t.id === todoId) {
                  const newIndent = Math.max(0, Math.min(3, (t.indent || 0) + delta));
                  return { ...t, indent: newIndent };
                }
                return t;
              })
            };
          }
          return g;
        });
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
      };

      const formatTime = (seconds) => {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = seconds % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      };

      const addDateSection = () => {
        const today = new Date().toISOString().split('T')[0];
        if (sections.some(s => s.date === today)) return;
        const newSection = { id: Date.now(), date: today };
        const newSections = [newSection, ...sections];
        setSections(newSections);
        saveToStorage(goals, newSections);
      };

      const deleteSection = (sectionId) => {
        const newSections = sections.filter(s => s.id !== sectionId);
        setSections(newSections);
        saveToStorage(goals, newSections);
      };

      const moveGoalToSection = (goalId, sectionId) => {
        const newGoals = goals.map(g => 
          g.id === goalId ? { ...g, sectionId } : g
        );
        setGoals(newGoals);
        saveToStorage(newGoals, sections);
        setDraggedGoal(null);
      };

      const noSectionGoals = goals.filter(g => !g.sectionId || g.listId);

      return (
        <div className="min-h-screen bg-black p-4" onClick={() => setEditingTodoId(null)}>
          <div className="max-w-4xl mx-auto">
            <div className="flex items-center justify-between mb-4">
              <h1 className="text-xl font-bold text-white">✓ 할일 목록</h1>
              <div className="flex gap-2">
                <button onClick={addDateSection} className="px-3 py-1 bg-green-500 hover:bg-green-400 text-white rounded text-sm">
                  + 날짜
                </button>
                <a href="index.html" className="px-3 py-1 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm">
                  메인으로
                </a>
              </div>
            </div>

            <div className="mb-6">
              <details className="group" open>
                <summary className="cursor-pointer text-lg font-bold text-gray-300 mb-2 py-2 list-none flex items-center gap-2 rounded"
                  onDragOver={(e) => {
                    e.preventDefault();
                    e.currentTarget.classList.add('bg-blue-900/20');
                  }}
                  onDragLeave={(e) => {
                    e.currentTarget.classList.remove('bg-blue-900/20');
                  }}
                  onDrop={(e) => {
                    e.preventDefault();
                    e.currentTarget.classList.remove('bg-blue-900/20');
                    if (draggedGoal) {
                      moveGoalToSection(draggedGoal, null);
                    }
                  }}
                >
                  <span className="transform group-open:rotate-90 transition-transform">▶</span>
                  <span>할일 모음</span>
                </summary>
                <div>
                  {noSectionGoals.length === 0 ? (
                    <div className="text-gray-500 text-sm px-1 py-2">대기중인 할일이 없습니다</div>
                  ) : (
                    noSectionGoals.map(goal => {
                      const isTimerActive = activeTimer === goal.id && !timerMemo;
                      const isEditingGoal = editingTodoId === `goal-${goal.id}`;
                      const isNoSectionGoal = true;
                      const goalKey = `nosection-${goal.id}`;
                      return (
                        <div 
                          key={`goal-${goal.id}`} 
                          className="flex items-center text-sm md:hover:bg-gray-800/20 rounded relative cursor-pointer" 
                          style={{ paddingLeft: `${(goal.indent || 0) * 20 + 4}px`, minHeight: '32px' }}
                          onClick={(e) => {
                            e.stopPropagation();
                            if (editingTodoId && editingTodoId.startsWith('goal-') && editingTodoId !== `goal-${goal.id}`) {
                              const prevGoalId = parseInt(editingTodoId.replace('goal-', ''));
                              const prevGoal = goals.find(g => g.id === prevGoalId);
                              if (prevGoal) {
                                updateGoal(prevGoal.id, editingText, prevGoal.estimatedMinutes, prevGoal.indent);
                              }
                            }
                            setEditingTodoId(`goal-${goal.id}`);
                            setEditingText(goal.name);
                          }}
                          draggable
                          onDragStart={(e) => {
                            setDraggedGoal(goal.id);
                            e.dataTransfer.effectAllowed = 'move';
                          }}
                          onDragEnd={() => setDraggedGoal(null)}
                          onDragOver={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                          }}
                          onDrop={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (draggedGoal && draggedGoal !== goal.id) {
                              const draggedGoalObj = goals.find(g => g.id === draggedGoal);
                              const targetGoalIndex = goals.findIndex(g => g.id === goal.id);
                              const newGoals = goals.filter(g => g.id !== draggedGoal);
                              newGoals.splice(targetGoalIndex, 0, { ...draggedGoalObj, sectionId: null });
                              setGoals(newGoals);
                              saveToStorage(newGoals, sections);
                            }
                          }}
                        >
                          <input 
                            type="checkbox" 
                            checked={!!goal.completedAt} 
                            onChange={() => toggleGoal(goal.id)} 
                            className="w-3.5 h-3.5 mr-2 flex-shrink-0" 
                            onClick={(e) => e.stopPropagation()}
                          />
                          {isEditingGoal ? (
                            <input
                              type="text"
                              value={editingText}
                              onChange={(e) => setEditingText(e.target.value)}
                              onBlur={() => {
                                updateGoal(goal.id, editingText, goal.estimatedMinutes, goal.indent);
                                setEditingTodoId(null);
                              }}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  e.preventDefault();
                                  const cursorPos = e.target.selectionStart;
                                  const beforeText = editingText.substring(0, cursorPos);
                                  const afterText = editingText.substring(cursorPos);
                                  const newGoal = {
                                    id: Date.now(),
                                    name: afterText,
                                    totalSeconds: 0,
                                    logs: [],
                                    todos: [],
                                    sectionId: goal.sectionId,
                                    indent: goal.indent || 0
                                  };
                                  const index = goals.findIndex(g => g.id === goal.id);
                                  const newGoals = [
                                    ...goals.slice(0, index),
                                    { ...goal, name: beforeText },
                                    newGoal,
                                    ...goals.slice(index + 1)
                                  ];
                                  setGoals(newGoals);
                                  saveToStorage(newGoals, sections);
                                  setEditingTodoId(`goal-${newGoal.id}`);
                                  setEditingText(afterText);
                                } else if (e.key === 'Escape') {
                                  setEditingTodoId(null);
                                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                                  e.preventDefault();
                                  const currentIndex = noSectionGoals.findIndex(g => g.id === goal.id);
                                  const nextIndex = e.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
                                  if (nextIndex >= 0 && nextIndex < noSectionGoals.length) {
                                    const nextGoal = noSectionGoals[nextIndex];
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, goal.indent);
                                    setEditingTodoId(`goal-${nextGoal.id}`);
                                    setEditingText(nextGoal.name);
                                  }
                                } else if (e.key === 'Tab') {
                                  e.preventDefault();
                                  const newIndent = Math.max(0, Math.min(3, (goal.indent || 0) + (e.shiftKey ? -1 : 1)));
                                  updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                } else if (e.key === 'Backspace' && e.target.selectionStart === 0) {
                                  e.preventDefault();
                                  const currentGoalIndex = noSectionGoals.findIndex(g => g.id === goal.id);
                                  const prevGoal = currentGoalIndex > 0 ? noSectionGoals[currentGoalIndex - 1] : null;
                                  if (prevGoal) {
                                    const prevText = prevGoal.name;
                                    const currentText = editingText;
                                    const newGoals = goals.map(g => {
                                      if (g.id === prevGoal.id) {
                                        return { ...g, name: prevText + currentText };
                                      }
                                      return g;
                                    }).filter(g => g.id !== goal.id);
                                    setGoals(newGoals);
                                    saveToStorage(newGoals, sections);
                                    setEditingTodoId(`goal-${prevGoal.id}`);
                                    setEditingText(prevText + currentText);
                                  }
                                } else if (e.key === 'Delete' && e.target.selectionStart === editingText.length) {
                                  e.preventDefault();
                                  const currentGoalIndex = noSectionGoals.findIndex(g => g.id === goal.id);
                                  const nextGoal = currentGoalIndex < noSectionGoals.length - 1 ? noSectionGoals[currentGoalIndex + 1] : null;
                                  if (nextGoal) {
                                    const currentText = editingText;
                                    const nextText = nextGoal.name;
                                    const newGoals = goals.map(g => {
                                      if (g.id === goal.id) {
                                        return { ...g, name: currentText + nextText };
                                      }
                                      return g;
                                    }).filter(g => g.id !== nextGoal.id);
                                    setGoals(newGoals);
                                    saveToStorage(newGoals, sections);
                                    setEditingText(currentText + nextText);
                                  }
                                }
                              }}
                              autoFocus
                              className="flex-1 py-2 bg-transparent border-none outline-none text-gray-200 font-medium"
                              onClick={(e) => e.stopPropagation()}
                            />
                          ) : (
                            <div className={`flex-1 py-2 font-medium break-words ${goal.completedAt ? 'line-through text-gray-500' : 'text-gray-200'}`}>
                              {goal.name}
                            </div>
                          )}
                          <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                            {!isEditingGoal && (
                              <>
                                {goal.estimatedMinutes && (
                                  <span className="text-gray-500 text-xs mr-1">{goal.estimatedMinutes}분</span>
                                )}
                                {goal.totalSeconds > 0 && (
                                  <span className="text-gray-400 text-xs font-mono mr-1">{formatTime(goal.totalSeconds)}</span>
                                )}
                              </>
                            )}
                            {isTimerActive && (
                              <>
                                <span className="text-cyan-300 text-xs font-mono">{formatTime(timerSeconds)}</span>
                                <button onClick={() => cancelTimer(goal.id)} className="px-1.5 py-0.5 bg-red-500 hover:bg-red-400 text-white rounded text-xs">
                                  <X size={12} />
                                </button>
                              </>
                            )}
                            {isEditingGoal && (
                              <>
                                <input
                                  type="number"
                                  value={tempMinutes[`goal-${goal.id}`] ?? goal.estimatedMinutes ?? ''}
                                  placeholder="분"
                                  onChange={(e) => setTempMinutes({...tempMinutes, [`goal-${goal.id}`]: e.target.value})}
                                  onBlur={(e) => {
                                    const mins = e.target.value ? parseInt(e.target.value) : undefined;
                                    updateGoal(goal.id, editingText, mins, goal.indent);
                                  }}
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  className="w-16 px-1 py-1 bg-gray-700 text-gray-100 rounded focus:outline-none border-0 text-sm"
                                />
                                <button
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  onClick={() => {
                                    const newIndent = Math.max(0, (goal.indent || 0) - 1);
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                  }}
                                  className="px-2 py-0.5 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'<'}
                                </button>
                                <button
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  onClick={() => {
                                    const newIndent = Math.min(3, (goal.indent || 0) + 1);
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                  }}
                                  className="px-2 py-0.5 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'>'}
                                </button>
                              </>
                            )}
                            <button
                              onClick={() => isTimerActive ? stopTimer(goal.id) : startTimer(goal.id)}
                              className={`px-1.5 py-0.5 rounded text-xs ${isTimerActive ? 'bg-rose-500 hover:bg-rose-400' : 'bg-green-500 hover:bg-green-400'} text-white`}
                            >
                              {isTimerActive ? <Pause size={12} /> : <Play size={12} />}
                            </button>
                          </div>
                        </div>
                      );
                    })
                  )}
                  <div className="text-gray-400 text-sm px-1 py-1 cursor-pointer hover:text-gray-200" onClick={() => addGoal(null)}>
                    + 할일 추가
                  </div>
                </div>
              </details>
            </div>

            {sections.map(section => {
              const sectionGoals = goals.filter(g => g.sectionId === section.id);
              return (
                <div 
                  key={`section-wrapper-${section.id}`}
                  onDragOver={(e) => e.preventDefault()}
                  onDrop={(e) => {
                    e.preventDefault();
                    if (draggedGoal) {
                      moveGoalToSection(draggedGoal, section.id);
                    }
                  }}
                >
                  <div 
                    key={`section-${section.id}`} 
                    className="flex items-center justify-between text-lg font-bold text-gray-300 mt-6 mb-2 px-1 py-2 group rounded"
                    onClick={() => setActiveSectionId(activeSectionId === section.id ? null : section.id)}
                  >
                    <span>{section.date}</span>
                    {(activeSectionId === section.id) && (
                      <button 
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteSection(section.id);
                        }} 
                        className="px-2 py-0.5 bg-red-500 hover:bg-red-400 text-white rounded text-xs"
                      >
                        삭제
                      </button>
                    )}
                  </div>
                  {sectionGoals.length === 0 && (
                    <div 
                      className="h-16 border-2 border-dashed border-gray-700 rounded mb-2 flex items-center justify-center text-gray-500 text-sm"
                      onDragOver={(e) => {
                        e.preventDefault();
                        e.currentTarget.classList.add('bg-blue-900/20', 'border-blue-500');
                      }}
                      onDragLeave={(e) => {
                        e.currentTarget.classList.remove('bg-blue-900/20', 'border-blue-500');
                      }}
                      onDrop={(e) => {
                        e.preventDefault();
                        e.currentTarget.classList.remove('bg-blue-900/20', 'border-blue-500');
                        if (draggedGoal) {
                          moveGoalToSection(draggedGoal, section.id);
                        }
                      }}
                    >
                      여기에 할일을 드래그하세요
                    </div>
                  )}
                  {sectionGoals.map(goal => {
                    const isTimerActive = activeTimer === goal.id && !timerMemo;
                    const isEditingGoal = editingTodoId === `goal-${goal.id}`;
                      return (
                        <div 
                          key={`goal-${goal.id}`} 
                          className="flex items-center text-sm md:hover:bg-gray-800/20 rounded relative cursor-pointer" 
                          style={{ paddingLeft: `${(goal.indent || 0) * 20 + 4}px`, minHeight: '32px' }}
                          onClick={(e) => {
                            e.stopPropagation();
                            if (editingTodoId && editingTodoId.startsWith('goal-') && editingTodoId !== `goal-${goal.id}`) {
                              const prevGoalId = parseInt(editingTodoId.replace('goal-', ''));
                              const prevGoal = goals.find(g => g.id === prevGoalId);
                              if (prevGoal) {
                                updateGoal(prevGoal.id, editingText, prevGoal.estimatedMinutes, prevGoal.indent);
                              }
                            }
                            setEditingTodoId(`goal-${goal.id}`);
                            setEditingText(goal.name);
                          }}
                          draggable
                          onDragStart={(e) => {
                            setDraggedGoal(goal.id);
                            e.dataTransfer.effectAllowed = 'move';
                          }}
                          onDragEnd={() => setDraggedGoal(null)}
                          onDragOver={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                          }}
                          onDrop={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (draggedGoal && draggedGoal !== goal.id) {
                              const draggedGoalObj = goals.find(g => g.id === draggedGoal);
                              const targetGoalIndex = goals.findIndex(g => g.id === goal.id);
                              const newGoals = goals.filter(g => g.id !== draggedGoal);
                              newGoals.splice(targetGoalIndex, 0, { ...draggedGoalObj, sectionId: goal.sectionId });
                              setGoals(newGoals);
                              saveToStorage(newGoals, sections);
                            }
                          }}
                        >
                          <input 
                            type="checkbox" 
                            checked={!!goal.completedAt} 
                            onChange={() => toggleGoal(goal.id)} 
                            className="w-3.5 h-3.5 mr-2 flex-shrink-0" 
                            onClick={(e) => e.stopPropagation()}
                          />
                          {isEditingGoal ? (
                            <input
                              type="text"
                              value={editingText}
                              onChange={(e) => setEditingText(e.target.value)}
                              onBlur={() => {
                                updateGoal(goal.id, editingText, goal.estimatedMinutes, goal.indent);
                                setEditingTodoId(null);
                              }}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  e.preventDefault();
                                  const cursorPos = e.target.selectionStart;
                                  const beforeText = editingText.substring(0, cursorPos);
                                  const afterText = editingText.substring(cursorPos);
                                  const newGoal = {
                                    id: Date.now(),
                                    name: afterText,
                                    totalSeconds: 0,
                                    logs: [],
                                    todos: [],
                                    sectionId: goal.sectionId,
                                    indent: goal.indent || 0
                                  };
                                  const index = goals.findIndex(g => g.id === goal.id);
                                  const newGoals = [
                                    ...goals.slice(0, index),
                                    { ...goal, name: beforeText },
                                    newGoal,
                                    ...goals.slice(index + 1)
                                  ];
                                  setGoals(newGoals);
                                  saveToStorage(newGoals, sections);
                                  setEditingTodoId(`goal-${newGoal.id}`);
                                  setEditingText(afterText);
                                } else if (e.key === 'Escape') {
                                  setEditingTodoId(null);
                                } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                                  e.preventDefault();
                                  const currentIndex = sectionGoals.findIndex(g => g.id === goal.id);
                                  const nextIndex = e.key === 'ArrowUp' ? currentIndex - 1 : currentIndex + 1;
                                  if (nextIndex >= 0 && nextIndex < sectionGoals.length) {
                                    const nextGoal = sectionGoals[nextIndex];
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, goal.indent);
                                    setEditingTodoId(`goal-${nextGoal.id}`);
                                    setEditingText(nextGoal.name);
                                  }
                                } else if (e.key === 'Tab') {
                                  e.preventDefault();
                                  const newIndent = Math.max(0, Math.min(3, (goal.indent || 0) + (e.shiftKey ? -1 : 1)));
                                  updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                } else if (e.key === 'Backspace' && e.target.selectionStart === 0) {
                                  e.preventDefault();
                                  const currentGoalIndex = sectionGoals.findIndex(g => g.id === goal.id);
                                  const prevGoal = currentGoalIndex > 0 ? sectionGoals[currentGoalIndex - 1] : null;
                                  if (prevGoal) {
                                    const prevText = prevGoal.name;
                                    const currentText = editingText;
                                    const newGoals = goals.map(g => {
                                      if (g.id === prevGoal.id) {
                                        return { ...g, name: prevText + currentText };
                                      }
                                      return g;
                                    }).filter(g => g.id !== goal.id);
                                    setGoals(newGoals);
                                    saveToStorage(newGoals, sections);
                                    setEditingTodoId(`goal-${prevGoal.id}`);
                                    setEditingText(prevText + currentText);
                                  }
                                } else if (e.key === 'Delete' && e.target.selectionStart === editingText.length) {
                                  e.preventDefault();
                                  const currentGoalIndex = sectionGoals.findIndex(g => g.id === goal.id);
                                  const nextGoal = currentGoalIndex < sectionGoals.length - 1 ? sectionGoals[currentGoalIndex + 1] : null;
                                  if (nextGoal) {
                                    const currentText = editingText;
                                    const nextText = nextGoal.name;
                                    const newGoals = goals.map(g => {
                                      if (g.id === goal.id) {
                                        return { ...g, name: currentText + nextText };
                                      }
                                      return g;
                                    }).filter(g => g.id !== nextGoal.id);
                                    setGoals(newGoals);
                                    saveToStorage(newGoals, sections);
                                    setEditingText(currentText + nextText);
                                  }
                                }
                              }}
                              autoFocus
                              className="flex-1 py-2 bg-transparent border-none outline-none text-gray-200 font-medium"
                              onClick={(e) => e.stopPropagation()}
                            />
                          ) : (
                            <div className={`flex-1 py-2 font-medium break-words ${goal.completedAt ? 'line-through text-gray-500' : 'text-gray-200'}`}>
                              {goal.name}
                            </div>
                          )}
                          <div className="flex items-center gap-1" onClick={(e) => e.stopPropagation()}>
                            {!isEditingGoal && (
                              <>
                                {goal.estimatedMinutes && (
                                  <span className="text-gray-500 text-xs mr-1">{goal.estimatedMinutes}분</span>
                                )}
                                {goal.totalSeconds > 0 && (
                                  <span className="text-gray-400 text-xs font-mono mr-1">{formatTime(goal.totalSeconds)}</span>
                                )}
                              </>
                            )}
                            {isTimerActive && (
                              <>
                                <span className="text-cyan-300 text-xs font-mono">{formatTime(timerSeconds)}</span>
                                <button onClick={() => cancelTimer(goal.id)} className="px-1.5 py-0.5 bg-red-500 hover:bg-red-400 text-white rounded text-xs">
                                  <X size={12} />
                                </button>
                              </>
                            )}
                            {isEditingGoal && (
                              <>
                                <input
                                  type="number"
                                  value={tempMinutes[`goal-${goal.id}`] ?? goal.estimatedMinutes ?? ''}
                                  placeholder="분"
                                  onChange={(e) => setTempMinutes({...tempMinutes, [`goal-${goal.id}`]: e.target.value})}
                                  onBlur={(e) => {
                                    const mins = e.target.value ? parseInt(e.target.value) : undefined;
                                    updateGoal(goal.id, editingText, mins, goal.indent);
                                  }}
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  className="w-16 px-1 py-1 bg-gray-700 text-gray-100 rounded focus:outline-none border-0 text-sm"
                                />
                                <button
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  onClick={() => {
                                    const newIndent = Math.max(0, (goal.indent || 0) - 1);
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                  }}
                                  className="px-2 py-0.5 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'<'}
                                </button>
                                <button
                                  onMouseDown={(e) => e.stopPropagation()}
                                  onTouchStart={(e) => e.stopPropagation()}
                                  onClick={() => {
                                    const newIndent = Math.min(3, (goal.indent || 0) + 1);
                                    updateGoal(goal.id, editingText, goal.estimatedMinutes, newIndent);
                                  }}
                                  className="px-2 py-0.5 bg-gray-600 text-white rounded text-xs"
                                >
                                  {'>'}
                                </button>
                              </>
                            )}
                            <button
                              onClick={() => isTimerActive ? stopTimer(goal.id) : startTimer(goal.id)}
                              className={`px-1.5 py-0.5 rounded text-xs ${isTimerActive ? 'bg-rose-500 hover:bg-rose-400' : 'bg-green-500 hover:bg-green-400'} text-white`}
                            >
                              {isTimerActive ? <Pause size={12} /> : <Play size={12} />}
                            </button>
                          </div>
                        </div>
                      );
                    })}
                    <div className="text-gray-400 text-sm px-1 py-1 mb-4 cursor-pointer hover:text-gray-200" onClick={() => addGoal(section.id)}>
                      + 할일 추가
                    </div>
                  </div>
                );
              })}
          </div>
        </div>
      );
    }

    createRoot(document.getElementById("root")).render(<TodosPage />);
  </script>
</body>
</html>
