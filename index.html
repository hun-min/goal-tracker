<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Targeted time</title>
    <link rel="icon" href="icon-192.svg?v=2" type="image/svg+xml" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#000000" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", "Noto Sans KR", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: #000;
      }

      .card-blur {
        background: rgba(15, 23, 42, 0.72);
        backdrop-filter: blur(12px);
        border: 2px solid rgba(148, 163, 184, 0.4);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }
      
      .card-complete {
        background: #022c22 !important;
        border: 2px solid #064e3b !important;
        backdrop-filter: none !important;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .card-today-pending {
        background: rgba(59, 130, 246, 0.1) !important;
        border: 2px solid rgba(59, 130, 246, 0.5) !important;
        box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
      }

      @keyframes pulse-glow {
        0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
        50% { box-shadow: 0 0 0 4px rgba(34, 197, 94, 0); }
      }

      .pulse-start {
        animation: pulse-glow 2s infinite;
      }

      @keyframes confetti {
        0% { transform: translateY(0) rotate(0deg); opacity: 1; }
        100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
      }

      .confetti {
        position: fixed;
        width: 10px;
        height: 10px;
        z-index: 9999;
        animation: confetti 3s ease-out forwards;
        pointer-events: none;
      }

      input::-webkit-inner-spin-button,
      input::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      * {
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
      }

      .no-drag {
        -webkit-user-drag: none;
        user-drag: none;
      }

      @media (max-width: 640px) {
        .ring-2, .ring-blue-400, .ring-yellow-400 {
          box-shadow: none !important;
          outline: none !important;
        }
      }
    </style>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen text-gray-100">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useCallback } from "https://esm.sh/react@18";
      import { createRoot } from "https://esm.sh/react-dom@18/client";
      import {
        Plus,
        Trash2,
        Play,
        Pause,
        Upload,
        Download,
        RefreshCcw,
        Info,
        ChevronUp,
        ChevronDown,
        X,
        Clock,
        GripVertical,
        Undo2
      } from "https://esm.sh/lucide-react@0.368.0";

      const TogglIntegration = {
        getApiToken() { return localStorage.getItem('toggl_api_token') || ''; },
        setApiToken(token) { localStorage.setItem('toggl_api_token', token); },
        isConnected() { return !!this.getApiToken(); },
        async startTimer(description, projectName = null) {
          const apiToken = this.getApiToken();
          if (!apiToken) return null;
          try {
            const response = await fetch('/api/toggl/start', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ apiToken, description, projectName })
            });
            if (!response.ok) {
              const error = await response.json();
              console.error('Toggl API error:', error);
              alert('Toggl 시작 실패: ' + (error.error || 'Unknown error'));
              return null;
            }
            const data = await response.json();
            return data.entryId;
          } catch (error) {
            console.error('Toggl start error:', error);
            return null;
          }
        },
        async stopTimer(entryId) {
          const apiToken = this.getApiToken();
          if (!apiToken || !entryId) return false;
          try {
            const response = await fetch('/api/toggl/stop', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ apiToken, entryId })
            });
            if (!response.ok) {
              const error = await response.json();
              console.error('Toggl stop error:', error);
              return false;
            }
            return true;
          } catch (error) {
            console.error('Toggl stop error:', error);
            return false;
          }
        }
      };

      const STORAGE_KEY = "goal-tracker-data-v1";
      const LISTS_STORAGE_KEY = "goal-tracker-lists-v1";
      const EXPORT_FILE_NAME = "goal-tracker-data.json";
      const DROPBOX_SYNC_PATH = "/Apps/goal-tracker/goals.json";
      const DROPBOX_BACKUP_PREFIX = "/Apps/goal-tracker/backup-";
      const MAX_BACKUPS = 10;
      const FILE_CONNECT_SHOWN_KEY = "goal-tracker-file-connect-shown";

      const hashData = (data) => {
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = ((hash << 5) - hash) + str.charCodeAt(i);
          hash = hash & hash;
        }
        return hash.toString();
      };

      const formatRelativeTime = (timestamp) => {
        if (!timestamp) return "";
        const diff = Math.max(0, Date.now() - timestamp);
        if (diff < 30000) return "방금 전";
        const minutes = Math.floor(diff / 60000);
        if (minutes < 60) return `${minutes}분 전`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}시간 전`;
        const days = Math.floor(hours / 24);
        if (days === 1) return "어제";
        return `${days}일 전`;
      };

      function useGoalDataPersistence({ goals, setGoals, lists, setLists, selectedListId, setSelectedListId }) {
        const fileInputRef = useRef(null);
        const fileHandleRef = useRef(null);
        const supportsFilePicker = useRef(
          typeof window !== "undefined" && typeof window.showSaveFilePicker === "function"
        ).current;
        const [statusMessage, setStatusMessage] = useState("로컬에 자동 저장됩니다.");
        const [lastSavedAt, setLastSavedAt] = useState(null);
        const [lastLoadedAt, setLastLoadedAt] = useState(null);
        const [isSyncing, setIsSyncing] = useState(false);
        const hasInitializedRef = useRef(false);
        const syncTimeoutRef = useRef(null);

        useEffect(() => {
          try {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
              const parsed = JSON.parse(stored);
              if (parsed && Array.isArray(parsed.goals)) {
                setGoals(parsed.goals);
                setStatusMessage("로컬 저장된 데이터를 불러왔습니다.");
                setLastLoadedAt(Date.now());
              }
            }
          } catch (err) {
            console.error("[sync] load failed", err);
            setStatusMessage("저장된 데이터를 불러오지 못했습니다.");
          } finally {
            hasInitializedRef.current = true;
          }
        }, [setGoals]);

        const goalsInitializedRef = useRef(false);
        useEffect(() => {
          if (!hasInitializedRef.current) return;
          if (!goalsInitializedRef.current) {
            goalsInitializedRef.current = true;
            return;
          }
          try {
            const existingData = localStorage.getItem(STORAGE_KEY);
            const parsed = existingData ? JSON.parse(existingData) : {};
            const savedAt = parsed.savedAt || new Date().toISOString();
            const sections = parsed.sections || [];
            const payload = JSON.stringify({ goals, sections, savedAt });
            localStorage.setItem(STORAGE_KEY, payload);
            setLastSavedAt(Date.now());
            setStatusMessage("변경 사항을 자동 저장했습니다.");
            
            if (syncTimeoutRef.current) clearTimeout(syncTimeoutRef.current);
            if (fileHandleRef.current) {
              syncTimeoutRef.current = setTimeout(async () => {
                const syncPayload = JSON.stringify({
                  syncedAt: savedAt,
                  goals,
                  lists: JSON.parse(localStorage.getItem(LISTS_STORAGE_KEY) || '{}').lists || [],
                  selectedListId: JSON.parse(localStorage.getItem(LISTS_STORAGE_KEY) || '{}').selectedListId
                }, null, 2);
                const synced = await writeFileHandle(fileHandleRef.current, syncPayload);
                if (!synced && !fileHandleRef.current) {
                  setStatusMessage("✗ 파일 연결 만료. 동기화 버튼을 눌러주세요.");
                }
              }, 3000);
            }
          } catch (err) {
            console.error("[sync] save failed", err);
            setStatusMessage("자동 저장에 실패했습니다. 저장 공간을 확인해주세요.");
          }
        }, [goals, lists, selectedListId, writeFileHandle]);

        const triggerImport = useCallback(() => {
          fileInputRef.current?.click();
        }, []);

        const writeFileHandle = useCallback(async (handle, contents) => {
          if (!handle?.createWritable) return false;
          try {
            const permissionOpts = { mode: "readwrite" };
            let permission = handle.queryPermission ? await handle.queryPermission(permissionOpts) : "prompt";
            if (permission !== "granted") {
              permission = handle.requestPermission ? await handle.requestPermission(permissionOpts) : "granted";
            }
            if (permission !== "granted") return false;
            const writable = await handle.createWritable();
            await writable.write(contents);
            await writable.close();
            return true;
          } catch (err) {
            console.error("[sync] write failed", err);
            if (err.name === "InvalidStateError") {
              fileHandleRef.current = null;
            }
            return false;
          }
        }, []);

        const handleFileSelected = useCallback(
          (event) => {
            const file = event.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
              try {
                const text = reader.result;
                const parsed = JSON.parse(text);
                                if (parsed && Array.isArray(parsed.goals)) {
                  setGoals(parsed.goals);

                  // Handle lists - if imported file has lists, use them, otherwise keep current
                  if (parsed.lists && Array.isArray(parsed.lists) && parsed.lists.length > 0) {
                    setLists(parsed.lists);
                    if (parsed.selectedListId) {
                      setSelectedListId(parsed.selectedListId);
                    }
                  } else {
                    // No lists in imported file, keep current lists and selection
                    // Don't change lists state
                  }

                  localStorage.setItem(
                    STORAGE_KEY,
                    JSON.stringify({ goals: parsed.goals, importedFrom: file.name, importedAt: new Date().toISOString() })
                  );

                  // Save lists data only if we have lists to save
                  if (parsed.lists && Array.isArray(parsed.lists)) {
                    localStorage.setItem(
                      LISTS_STORAGE_KEY,
                      JSON.stringify({
                        lists: parsed.lists,
                        selectedListId: parsed.selectedListId,
                        togglApiToken: parsed.togglApiToken || '',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString()
                      })
                    );
                    if (parsed.togglApiToken) {
                      TogglIntegration.setApiToken(parsed.togglApiToken);
                    }
                  }

                  setStatusMessage(`${file.name}에서 데이터를 불러왔습니다.`);
                  setLastLoadedAt(Date.now());
                } else {
                  setStatusMessage("선택한 파일에 목표 데이터가 없습니다.");
                }
              } catch (err) {
                console.error("[sync] import failed", err);
                setStatusMessage("파일을 읽는 중 문제가 발생했습니다.");
              } finally {
                event.target.value = "";
              }
            };
            reader.readAsText(file, "utf-8");
          },
          [setGoals, setLists, setSelectedListId]
        );

        const triggerExport = useCallback(async () => {
          const payload = JSON.stringify(
            {
              exportedAt: new Date().toISOString(),
              goals,
              lists,
              selectedListId
            },
            null,
            2
          );

          if (supportsFilePicker) {
            try {
              const handle = await window.showSaveFilePicker({
                suggestedName: EXPORT_FILE_NAME,
                types: [
                  {
                    description: "Goal Tracker JSON",
                    accept: { "application/json": [".json"] }
                  }
                ]
              });
              const wrote = await writeFileHandle(handle, payload);
              if (wrote) {
                fileHandleRef.current = handle;
                setStatusMessage("선택한 위치에 저장했습니다. 다음에는 동기화 버튼으로 덮어쓸 수 있습니다.");
                setLastSavedAt(Date.now());
                return;
              }
            } catch (err) {
              if (err?.name === "AbortError") {
                setStatusMessage("파일 저장을 취소했습니다.");
                return;
              }
              console.error("[sync] export failed via picker", err);
            }
          }

          try {
            const blob = new Blob([payload], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement("a");
            anchor.href = url;
            anchor.download = EXPORT_FILE_NAME;
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            URL.revokeObjectURL(url);
            setStatusMessage("파일을 다운로드했습니다. 필요한 위치로 이동해 Resilio Sync 폴더에 두세요.");
            setLastSavedAt(Date.now());
          } catch (err) {
            console.error("[sync] export failed", err);
            setStatusMessage("파일로 저장하지 못했습니다. 브라우저 권한을 확인해주세요.");
          }
        }, [goals, lists, selectedListId, supportsFilePicker, writeFileHandle]);

        const triggerSync = useCallback(async () => {
          setIsSyncing(true);
          const localData = localStorage.getItem(STORAGE_KEY);
          const savedAt = localData ? JSON.parse(localData).savedAt : new Date().toISOString();
          const payload = JSON.stringify(
            {
              syncedAt: savedAt,
              goals,
              lists,
              selectedListId
            },
            null,
            2
          );

          if (!fileHandleRef.current) {
            // No file handle, trigger export flow
            if (supportsFilePicker) {
              try {
                const handle = await window.showSaveFilePicker({
                  suggestedName: EXPORT_FILE_NAME,
                  types: [
                    {
                      description: "Goal Tracker JSON",
                      accept: { "application/json": [".json"] }
                    }
                  ]
                });
                const wrote = await writeFileHandle(handle, payload);
                if (wrote) {
                  fileHandleRef.current = handle;
                  setStatusMessage("✓ 파일 저장 완료! 다음부터 자동 동기화됩니다.");
                  setLastSavedAt(Date.now());
                  setTimeout(() => setStatusMessage("로컬에 자동 저장됩니다."), 2000);
                  setIsSyncing(false);
                  return;
                }
              } catch (err) {
                if (err?.name === "AbortError") {
                  setStatusMessage("파일 저장을 취소했습니다.");
                  setIsSyncing(false);
                  return;
                }
              }
            }
            // Fallback to download
            try {
              const blob = new Blob([payload], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const anchor = document.createElement("a");
              anchor.href = url;
              anchor.download = EXPORT_FILE_NAME;
              document.body.appendChild(anchor);
              anchor.click();
              document.body.removeChild(anchor);
              URL.revokeObjectURL(url);
              setStatusMessage("파일을 다운로드했습니다.");
              setLastSavedAt(Date.now());
            } catch (err) {
              setStatusMessage("파일 저장에 실패했습니다.");
            }
            setIsSyncing(false);
            return;
          }

          setStatusMessage("동기화 중...");
          try {
            const synced = await writeFileHandle(fileHandleRef.current, payload);
            if (synced) {
              setStatusMessage("✓ 동기화 완료!");
              setLastSavedAt(Date.now());
              setTimeout(() => setStatusMessage("로컬에 자동 저장됩니다."), 2000);
            } else {
              if (!fileHandleRef.current) {
                setStatusMessage("✗ 파일 연결 만료. 다시 동기화해주세요.");
              } else {
                setStatusMessage("✗ 동기화 실패. 다시 시도해주세요.");
              }
            }
          } catch (err) {
            setStatusMessage("✗ 동기화 오류 발생.");
          }
          setIsSyncing(false);
        }, [goals, lists, selectedListId, writeFileHandle, supportsFilePicker]);

        return {
          fileInputRef,
          fileHandleRef,
          triggerImport,
          handleFileSelected,
          triggerExport,
          triggerSync,
          statusMessage,
          lastSavedAt,
          lastLoadedAt,
          storageKey: STORAGE_KEY,
          exportFileName: EXPORT_FILE_NAME,
          supportsFilePicker,
          writeFileHandle,
          isSyncing
        };
      }

      function GoalTracker() {
        const [goals, setGoals] = useState([]);
        const [lists, setLists] = useState([]);
        const [selectedListId, setSelectedListId] = useState(null);
        const goalColors = useRef({});
        const availableColors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16'];
        const [isSidebarOpen, setIsSidebarOpen] = useState(false);
        const [listsEditMode, setListsEditMode] = useState(false);
        const [draggingListId, setDraggingListId] = useState(null);
        const [dragOverListId, setDragOverListId] = useState(null);
        const [dropboxConnected, setDropboxConnected] = useState(false);
        const [dropboxSyncing, setDropboxSyncing] = useState(false);
        const [showDropboxMenu, setShowDropboxMenu] = useState(false);
        const [lastDropboxSync, setLastDropboxSync] = useState(null);
        const lastUploadHashRef = useRef(null);
        const [selectedCardIndex, setSelectedCardIndex] = useState(0);
        const [selectedFieldIndex, setSelectedFieldIndex] = useState(-1);
        const [showShortcuts, setShowShortcuts] = useState(false);
        const [sidebarFocused, setSidebarFocused] = useState(false);
        const [selectedListIndex, setSelectedListIndex] = useState(0);
        const [newGoalName, setNewGoalName] = useState("");
        const [newGoalTargetHours, setNewGoalTargetHours] = useState("");
        const [newGoalTargetMinutes, setNewGoalTargetMinutes] = useState("");
        const [editingGoalName, setEditingGoalName] = useState(null);
        const [editingTargetHours, setEditingTargetHours] = useState(null);
        const [editingTargetMinutes, setEditingTargetMinutes] = useState(null);
        const [activeTimer, setActiveTimer] = useState(null);
        const [timerSeconds, setTimerSeconds] = useState(0);
        const [timerStartTime, setTimerStartTime] = useState(null);
        const [togglEntryId, setTogglEntryId] = useState(null);
        const [togglApiToken, setTogglApiToken] = useState(TogglIntegration.getApiToken());
        const [showTogglSettings, setShowTogglSettings] = useState(false);
        const [togglFormat, setTogglFormat] = useState(() => localStorage.getItem('toggl_format') || '( {current} / {target} | {progress}% )');
        const [togglRunning, setTogglRunning] = useState(false);
        const persistence = useGoalDataPersistence({
          goals,
          setGoals,
          lists,
          setLists,
          selectedListId,
          setSelectedListId
        });
        
        // Assign colors to goals on load
        useEffect(() => {
          goals.forEach((g, idx) => {
            if (!goalColors.current[g.id]) {
              goalColors.current[g.id] = g.color || availableColors[idx % availableColors.length];
            }
          });
        }, [goals]);
        const [showToast, setShowToast] = useState(false);
        const toastTimeoutRef = useRef(null);
        const [expandedGoals, setExpandedGoals] = useState(() => new Set());
        const [expandedLogsGoals, setExpandedLogsGoals] = useState(() => new Set());
        const [editingLogsGoals, setEditingLogsGoals] = useState(() => new Set());
        const [expandedTodos, setExpandedTodos] = useState(() => new Set());
        const [selectedTab, setSelectedTab] = useState(() => new Map());
        const [showAddLog, setShowAddLog] = useState(null);
        const [newLogHours, setNewLogHours] = useState("");
        const [newLogMinutes, setNewLogMinutes] = useState("");
        const [newLogDate, setNewLogDate] = useState("");
        const [newLogMemo, setNewLogMemo] = useState("");
        const [newLogStartTime, setNewLogStartTime] = useState("");
        const [newLogEndTime, setNewLogEndTime] = useState("");
        const [timerMemo, setTimerMemo] = useState("");
        const [editingLogIndex, setEditingLogIndex] = useState(null);
        const [editLogMemo, setEditLogMemo] = useState("");
        const [editLogStartTime, setEditLogStartTime] = useState("");
        const [editLogEndTime, setEditLogEndTime] = useState("");
        const [editingTodoId, setEditingTodoId] = useState(null);
        const [selectedTodoId, setSelectedTodoId] = useState(null);
        const [showAddTodo, setShowAddTodo] = useState(null);
        const [newTodoText, setNewTodoText] = useState("");
        const [history, setHistory] = useState([]);
        const [historyIndex, setHistoryIndex] = useState(-1);
        const [draggingGoalId, setDraggingGoalId] = useState(null);
        const [dragOverGoalId, setDragOverGoalId] = useState(null);
        const [dragPosition, setDragPosition] = useState('before'); // 'before' or 'after'
        const [cardsEditMode, setCardsEditMode] = useState(false);
        const [touchStartX, setTouchStartX] = useState(null);
        const [touchStartY, setTouchStartY] = useState(null);

        const [contextMenu, setContextMenu] = useState(null);
        const [listContextMenu, setListContextMenu] = useState(null);
        const [todoContextMenu, setTodoContextMenu] = useState(null);
        const [logContextMenu, setLogContextMenu] = useState(null);
        const [showDailySuggestion, setShowDailySuggestion] = useState(true);
        const [confetti, setConfetti] = useState([]);
        const [showWeeklyReport, setShowWeeklyReport] = useState(false);
        const [showTimeline, setShowTimeline] = useState(false);
        const [timelineView, setTimelineView] = useState('timeline'); // 'timeline' or 'calendar'
        const [calendarDate, setCalendarDate] = useState(new Date());
        const [selectedDate, setSelectedDate] = useState(null);
        const [showStats, setShowStats] = useState(false);
        const [showCompactTodos, setShowCompactTodos] = useState(false);
        const [nextGoalSuggestion, setNextGoalSuggestion] = useState(null);
        const [todoShowCounts, setTodoShowCounts] = useState(() => new Map());
        const [logShowCounts, setLogShowCounts] = useState(() => new Map());
        const [editingTodoCount, setEditingTodoCount] = useState(null);
        const [editingLogCount, setEditingLogCount] = useState(null);
        const notificationSoundRef = useRef(null);
        const cardRefs = useRef([]);
        const syncTimeoutRef = useRef(null);
        const dropboxInitializedRef = useRef(false);



        // Check Dropbox connection status and smart sync on load
        useEffect(() => {
          if (window.location.protocol === 'file:') {
            dropboxInitializedRef.current = true;
            return;
          }
          
          // 매번 새로 연결 상태 확인 및 자동 연결
          const checkConnection = async () => {
            // 아예 처음부터 새로 로그인
            try {
              await fetch('/api/dropbox/disconnect');
              await new Promise(r => setTimeout(r, 500));
              connectDropbox();
            } catch (e) {
              connectDropbox();
            }
            dropboxInitializedRef.current = true;
            
            fetch('/api/dropbox/status')
              .then(r => r.json())
              .then(data => {
                if (!data.connected) {
                  // 연결 안되어 있으면 자동 연결 시도
                  connectDropbox();
                } else {
                  setDropboxConnected(true);
                }
              
              // Smart sync in background (non-blocking)
              if (data.connected) {
                setTimeout(async () => {
                  try {
                    const res = await fetch('/api/dropbox/sync', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ mode: 'pull' })
                    });
                    const response = await res.json();
                    const dropboxData = response.contents ? JSON.parse(response.contents) : null;
                    
                    const localData = localStorage.getItem(STORAGE_KEY);
                    const localParsed = localData ? JSON.parse(localData) : null;
                    const localTime = localParsed?.savedAt ? new Date(localParsed.savedAt).getTime() : 0;
                    const dropboxTime = dropboxData?.savedAt ? new Date(dropboxData.savedAt).getTime() : 0;
                    
                    console.log('[INIT] Dropbox time:', dropboxTime, 'Local time:', localTime);
                    
                    // 안전장치: 빈 데이터로 덮어쓰기 방지
                    const dropboxHasData = dropboxData?.goals && dropboxData.goals.length > 0;
                    const localHasData = localParsed?.goals && localParsed.goals.length > 0;
                    
                    if (dropboxHasData && dropboxTime >= localTime) {
                      // Dropbox가 로컬보다 최신이거나 같을 때만 적용
                      console.log('[INIT] Loading from Dropbox (newer or equal)');
                      // 중요: dropboxInitializedRef를 true로 설정한 후 setGoals 호출
                      // 이렇게 하면 setGoals가 트리거하는 useEffect에서 자동 업로드 안 함
                      dropboxInitializedRef.current = true;
                      setGoals(dropboxData.goals);
                      if (dropboxData.lists) setLists(dropboxData.lists);
                      if (dropboxData.selectedListId) setSelectedListId(dropboxData.selectedListId);
                      if (dropboxData.togglApiToken) {
                        TogglIntegration.setApiToken(dropboxData.togglApiToken);
                        setTogglApiToken(dropboxData.togglApiToken);
                      }
                      setLastDropboxSync(Date.now());
                    } else if (!dropboxHasData && localHasData) {
                      // Dropbox가 비어있고 로컬에 데이터가 있으면 업로드 (서버 오류 시 스킵)
                      console.log('[INIT] Uploading local to Dropbox (Dropbox empty)');
                      try {
                        const localListsData = localStorage.getItem(LISTS_STORAGE_KEY);
                        const localListsParsed = localListsData ? JSON.parse(localListsData) : {};
                        const payload = { 
                          goals: localParsed.goals, 
                          lists: localListsParsed.lists || [], 
                          selectedListId: localListsParsed.selectedListId,
                          togglApiToken: localListsParsed.togglApiToken || '',
                          savedAt: new Date().toISOString()
                        };
                        const uploadRes = await fetch('/api/dropbox/sync', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ mode: 'push', contents: JSON.stringify(payload) })
                        });
                        if (uploadRes.ok) {
                          setLastDropboxSync(Date.now());
                        }
                      } catch (err) {
                        console.log('[INIT] Upload failed, skipping');
                      }
                    } else if (localTime > dropboxTime && localHasData) {
                      // 로컬이 최신이고 데이터가 있으면 업로드 (서버 오류 시 스킵)
                      console.log('[INIT] Uploading local to Dropbox (local newer)');
                      try {
                        const localListsData = localStorage.getItem(LISTS_STORAGE_KEY);
                        const localListsParsed = localListsData ? JSON.parse(localListsData) : {};
                        const payload = { 
                          goals: localParsed.goals, 
                          lists: localListsParsed.lists || [], 
                          selectedListId: localListsParsed.selectedListId,
                          togglApiToken: localListsParsed.togglApiToken || '',
                          savedAt: localParsed.savedAt
                        };
                        const uploadRes = await fetch('/api/dropbox/sync', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ mode: 'push', contents: JSON.stringify(payload) })
                        });
                        if (uploadRes.ok) {
                          setLastDropboxSync(Date.now());
                        }
                      } catch (err) {
                        console.log('[INIT] Upload failed, skipping');
                      }
                    }
                  } catch (err) {
                    console.error('Smart sync failed:', err);
                  } finally {
                    if (!dropboxInitializedRef.current) {
                      dropboxInitializedRef.current = true;
                    }
                  }
                }, 100);
              } else {
                dropboxInitializedRef.current = true;
              }
              })
              .catch(() => {
                setDropboxConnected(false);
                dropboxInitializedRef.current = true;
              });
          };
          
          checkConnection();
          // 5분마다 연결 상태 재확인
          const statusInterval = setInterval(checkConnection, 300000);
          
          return () => clearInterval(statusInterval);
        }, []);

        // 1분마다 Dropbox 확인 (화면 켜져있을 때만)
        useEffect(() => {
          if (!dropboxConnected) return;
          
          let errorCount = 0;
          const syncIfVisible = async () => {
            if (document.hidden || errorCount >= 3) return;
            try {
              const res = await fetch('/api/dropbox/sync', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: 'pull' })
              });
              if (!res.ok) {
                if (res.status === 500 || res.status === 401 || res.status === 403) {
                  // 토큰 만료 시 자동 재연결
                  await fetch('/api/dropbox/disconnect');
                  setDropboxConnected(false);
                  setTimeout(() => connectDropbox(), 2000);
                  errorCount = 10; // 재연결 시도 중이므로 루프 중단
                  return;
                }
                errorCount++;
                return;
              }
              errorCount = 0; // 성공 시 리셋
              const response = await res.json();
              const dropboxData = response.contents ? JSON.parse(response.contents) : null;
              
              const localData = localStorage.getItem(STORAGE_KEY);
              const localSavedAt = localData ? JSON.parse(localData).savedAt : null;
              const dropboxSavedAt = dropboxData?.savedAt;
              
              // Only update if Dropbox has newer data
              if (dropboxData?.goals && dropboxSavedAt && dropboxSavedAt !== localSavedAt) {
                dropboxInitializedRef.current = false;
                setGoals(dropboxData.goals);
                if (dropboxData.lists) setLists(dropboxData.lists);
                if (dropboxData.selectedListId) setSelectedListId(dropboxData.selectedListId);
                if (dropboxData.togglApiToken) {
                  TogglIntegration.setApiToken(dropboxData.togglApiToken);
                  setTogglApiToken(dropboxData.togglApiToken);
                }
                setLastDropboxSync(Date.now());
                setTimeout(() => { dropboxInitializedRef.current = true; }, 100);
              }
            } catch (err) {
              errorCount++;
            }
          };
          
          const interval = setInterval(syncIfVisible, 60000);
          const handleVisibilityChange = () => { if (!document.hidden) syncIfVisible(); };
          document.addEventListener('visibilitychange', handleVisibilityChange);
          
          return () => {
            clearInterval(interval);
            document.removeEventListener('visibilitychange', handleVisibilityChange);
          };
        }, [dropboxConnected]);

        const connectDropbox = async () => {
          try {
            const res = await fetch('/api/dropbox/auth/start');
            const { authUrl } = await res.json();
            const popup = window.open(authUrl, 'dropbox-auth', 'width=600,height=700');
            if (!popup) {
              alert('팝업이 차단되었습니다. 팝업을 허용해주세요.');
              return;
            }
            const checkPopup = setInterval(() => {
              if (popup.closed) {
                clearInterval(checkPopup);
                // 연결 상태 새로 확인
                setTimeout(() => {
                  fetch('/api/dropbox/status')
                    .then(r => r.json())
                    .then(data => {
                      setDropboxConnected(data.connected);
                      if (data.connected) {
                        // 로그인 성공 시 데이터 불러오기
                        syncFromDropbox(true);
                      }
                    })
                    .catch(() => setDropboxConnected(false));
                }, 1000);
              }
            }, 500);
          } catch (err) {
            alert('Dropbox 연결 실패');
          }
        };

        const disconnectDropbox = async () => {
          try {
            await fetch('/api/dropbox/disconnect');
            setDropboxConnected(false);
            setShowDropboxMenu(false);
          } catch (err) {
            setDropboxConnected(false);
            setShowDropboxMenu(false);
          }
        };

        const syncToDropbox = async () => {
          if (!dropboxConnected) {
            connectDropbox();
            return;
          }
          setDropboxSyncing(true);
          try {
            const payload = { goals, lists, selectedListId, togglApiToken, savedAt: new Date().toISOString() };
            const contents = JSON.stringify(payload);
            
            // Upload main file with retry
            let res;
            let lastError;
            for (let i = 0; i < 3; i++) {
              try {
                res = await fetch('/api/dropbox/sync', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: 'push', contents })
                });
                if (res.ok) break;
                lastError = `HTTP ${res.status}`;
                if (res.status === 500 || res.status === 401 || res.status === 403) {
                  // 토큰 만료 시 자동 재연결
                  await fetch('/api/dropbox/disconnect');
                  setDropboxConnected(false);
                  setTimeout(() => connectDropbox(), 1000);
                  throw new Error('토큰 만료 - 자동 재연결 중');
                }
              } catch (err) {
                lastError = err.message;
              }
              if (i < 2) await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
            if (!res || !res.ok) {
              throw new Error(lastError || 'Upload failed');
            }
            await res.json();
            
            // Create backup with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            await fetch('/api/dropbox/sync', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ mode: 'push', contents, path: `${DROPBOX_BACKUP_PREFIX}${timestamp}.json` })
            });
            
            // List and delete old backups (keep only 10)
            const listRes = await fetch('/api/dropbox/list');
            const files = await listRes.json();
            const backups = files.filter(f => f.path_lower.startsWith(DROPBOX_BACKUP_PREFIX.toLowerCase())).sort((a, b) => b.path_lower.localeCompare(a.path_lower));
            for (let i = MAX_BACKUPS; i < backups.length; i++) {
              await fetch('/api/dropbox/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: backups[i].path_lower })
              });
            }
            
            setLastDropboxSync(Date.now());
            alert('✓ Dropbox 업로드 완료');
          } catch (err) {
            alert('✗ 업로드 실패: ' + (err.message || '알 수 없는 오류'));
          } finally {
            setDropboxSyncing(false);
          }
        };

        const syncFromDropbox = async (silent = false) => {
          if (!dropboxConnected) {
            connectDropbox();
            return;
          }
          setDropboxSyncing(true);
          try {
            let res;
            let lastError;
            for (let i = 0; i < 3; i++) {
              try {
                res = await fetch('/api/dropbox/sync', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: 'pull' })
                });
                if (res.ok) break;
                lastError = `HTTP ${res.status}`;
                if (res.status === 500 || res.status === 401 || res.status === 403) {
                  // 토큰 만료 시 자동 재연결
                  await fetch('/api/dropbox/disconnect');
                  setDropboxConnected(false);
                  if (!silent) setTimeout(() => connectDropbox(), 1000);
                  throw new Error('토큰 만료 - 자동 재연결 중');
                }
              } catch (err) {
                lastError = err.message;
              }
              if (i < 2) await new Promise(r => setTimeout(r, 1000 * (i + 1)));
            }
            if (!res || !res.ok) {
              throw new Error(lastError || 'Download failed');
            }
            const response = await res.json();
            if (response.error) {
              if (!silent) alert(`✗ ${response.message || response.error}`);
              return;
            }
            const data = response.contents ? JSON.parse(response.contents) : null;
            
            const dropboxHasData = data?.goals && data.goals.length > 0;
            const localHasData = goals && goals.length > 0;
            
            if (!dropboxHasData && localHasData) {
              if (!silent) alert('⚠️ Dropbox 데이터가 비어있어 로컬 데이터를 유지합니다.');
              setDropboxSyncing(false);
              return;
            }
            
            dropboxInitializedRef.current = false;
            if (data?.goals) setGoals(data.goals);
            if (data?.lists) setLists(data.lists);
            if (data?.selectedListId) setSelectedListId(data.selectedListId);
            if (data?.togglApiToken) {
              TogglIntegration.setApiToken(data.togglApiToken);
              setTogglApiToken(data.togglApiToken);
            }
            setLastDropboxSync(Date.now());
            setTimeout(() => { dropboxInitializedRef.current = true; }, 100);
            if (!silent) alert('✓ Dropbox 다운로드 완료');
          } catch (err) {
            if (!silent) alert('✗ 다운로드 실패: ' + (err.message || '알 수 없는 오류'));
          } finally {
            setDropboxSyncing(false);
          }
        };

        // Load timer state on mount
        useEffect(() => {
          try {
            const saved = localStorage.getItem('timer-state');
            if (saved) {
              const { activeTimer: savedTimer, timerStartTime: savedStart, togglEntryId: savedEntryId } = JSON.parse(saved);
              if (savedTimer && savedStart) {
                const elapsed = Math.floor((Date.now() - savedStart) / 1000);
                setActiveTimer(savedTimer);
                setTimerSeconds(elapsed);
                setTimerStartTime(savedStart);
                if (savedEntryId) setTogglEntryId(savedEntryId);
              }
            }
          } catch (err) {}
        }, []);

        useEffect(() => {
          if (!togglApiToken) return;
          const check = async () => {
            try {
              const res = await fetch(`/api/toggl/current?apiToken=${encodeURIComponent(togglApiToken)}`);
              if (res.ok) {
                const data = await res.json();
                setTogglRunning(data.running);
              }
            } catch (err) {}
          };
          check();
          const interval = setInterval(check, 30000);
          return () => clearInterval(interval);
        }, [togglApiToken]);

        useEffect(() => {
          if (activeTimer === null || !timerStartTime) return undefined;
          const updateTimer = () => {
            if (!document.hidden) {
              setTimerSeconds(Math.floor((Date.now() - timerStartTime) / 1000));
            }
          };
          const interval = setInterval(updateTimer, 1000);
          return () => clearInterval(interval);
        }, [activeTimer, timerStartTime]);

        // Load lists/selection from separate storage (only once on mount)
        useEffect(() => {
          try {
            const raw = localStorage.getItem(LISTS_STORAGE_KEY);
            let loadedLists = [];
            let loadedSelectedId = null;
            let loadedTogglToken = '';

            if (raw) {
              const parsed = JSON.parse(raw);
              if (Array.isArray(parsed?.lists)) {
                loadedLists = parsed.lists;
              }
              if (parsed?.selectedListId) {
                loadedSelectedId = parsed.selectedListId;
              }
              if (parsed?.togglApiToken) {
                loadedTogglToken = parsed.togglApiToken;
                TogglIntegration.setApiToken(loadedTogglToken);
                setTogglApiToken(loadedTogglToken);
              }
            }

            // Ensure at least default list exists
            if (loadedLists.length === 0) {
              loadedLists = [{ id: "default", name: "기본함" }];
            }

            // Set valid selectedId or use first list
            if (!loadedSelectedId || !loadedLists.find(l => l.id === loadedSelectedId)) {
              loadedSelectedId = loadedLists[0].id;
            }

            setLists(loadedLists);
            setSelectedListId(loadedSelectedId);
          } catch (err) {
            // Fallback to default
            const defaultList = { id: "default", name: "기본함" };
            setLists([defaultList]);
            setSelectedListId("default");
          }
        }, []);

        const listsInitializedRef = useRef(false);
        useEffect(() => {
          if (lists.length > 0) {
            if (!listsInitializedRef.current) {
              listsInitializedRef.current = true;
              return;
            }
            try {
              const localData = localStorage.getItem(STORAGE_KEY);
              const savedAt = localData ? JSON.parse(localData).savedAt : new Date().toISOString();
              const payload = JSON.stringify({ lists, selectedListId, togglApiToken, savedAt });
              localStorage.setItem(LISTS_STORAGE_KEY, payload);
            } catch (err) {}
          }
        }, [lists, selectedListId, togglApiToken]);

        // Auto-sync to Dropbox (only when data actually changes)
        const dataInitializedRef = useRef(false);
        const lastBackupTimeRef = useRef(0);
        useEffect(() => {
          if (!dataInitializedRef.current || !dropboxInitializedRef.current) {
            dataInitializedRef.current = true;
            return;
          }
          if (syncTimeoutRef.current) clearTimeout(syncTimeoutRef.current);
          
          if (dropboxConnected && goals.length > 0) {
            syncTimeoutRef.current = setTimeout(async () => {
              try {
                const localData = localStorage.getItem(STORAGE_KEY);
                const savedAt = localData ? JSON.parse(localData).savedAt : new Date().toISOString();
                const payload = { goals, lists, selectedListId, togglApiToken, savedAt };
                const contents = JSON.stringify(payload);
                
                await fetch('/api/dropbox/sync', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ mode: 'push', contents })
                });
                
                // Create backup every 1 hour
                const now = Date.now();
                if (now - lastBackupTimeRef.current > 3600000) {
                  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                  await fetch('/api/dropbox/sync', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'push', contents, path: `${DROPBOX_BACKUP_PREFIX}${timestamp}.json` })
                  });
                  
                  const listRes = await fetch('/api/dropbox/list');
                  const files = await listRes.json();
                  const backups = files.filter(f => f.path_lower?.startsWith('/apps/goal-tracker/backup-')).sort((a, b) => b.path_lower.localeCompare(a.path_lower));
                  for (let i = MAX_BACKUPS; i < backups.length; i++) {
                    await fetch('/api/dropbox/delete', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ path: backups[i].path_lower })
                    });
                  }
                  
                  lastBackupTimeRef.current = now;
                }
                
                setLastDropboxSync(Date.now());
              } catch (err) {}
            }, 2000);
          }
        }, [goals, lists, selectedListId, togglApiToken, dropboxConnected]);

        const saveHistory = (newGoals) => {
          setHistory((prev) => {
            const newHistory = prev.slice(0, historyIndex + 1);
            newHistory.push(JSON.parse(JSON.stringify(newGoals)));
            if (newHistory.length > 50) newHistory.shift();
            return newHistory;
          });
          setHistoryIndex((prev) => Math.min(prev + 1, 49));
        };

        const undo = () => {
          if (historyIndex > 0) {
            setHistoryIndex((prev) => prev - 1);
            setGoals(JSON.parse(JSON.stringify(history[historyIndex - 1])));
          }
        };

        const redo = () => {
          if (historyIndex < history.length - 1) {
            setHistoryIndex((prev) => prev + 1);
            setGoals(JSON.parse(JSON.stringify(history[historyIndex + 1])));
          }
        };

        const addGoal = () => {
          const trimmedName = newGoalName.trim();
          if (!trimmedName) return;
          const hours = parseFloat(newGoalTargetHours) || 0;
          const minutes = parseFloat(newGoalTargetMinutes) || 0;
          const totalHours = hours + minutes / 60;
          const newId = Date.now();
          const color = availableColors[Object.keys(goalColors.current).length % availableColors.length];
          goalColors.current[newId] = color;
          setGoals((prevGoals) => {
            const newGoals = [
              {
                id: newId,
                name: trimmedName,
                targetHours: totalHours,
                totalSeconds: 0,
                logs: [],
                todos: [],
                createdAt: new Date(),
                completedAt: null,
                listId: selectedListId || "default",
                color: color
              },
              ...prevGoals
            ];
            saveHistory(newGoals);
            return newGoals;
          });
          setNewGoalName("");
          setNewGoalTargetHours("");
          setNewGoalTargetMinutes("");
        };

        const addList = (name) => {
          const trimmed = (name || "").trim();
          if (!trimmed) return;
          const id = `list-${Date.now()}`;
          setLists((prev) => [...prev, { id, name: trimmed }]);
          setSelectedListId(id);
        };

        const deleteList = (id) => {
          if (!id) return;
          const hasGoals = goals.some((g) => (g.listId || "default") === id);
          if (hasGoals) {
            alert("리스트에 목표가 있어 삭제할 수 없습니다.");
            return;
          }
          setLists((prev) => prev.filter((l) => l.id !== id));
          if (selectedListId === id) setSelectedListId(lists.find((l) => l.id !== id)?.id || "default");
        };

        const handleListKeyDown = (e) => {
          if (e.key === 'Enter') {
            const val = e.currentTarget.value;
            addList(val);
            e.currentTarget.value = '';
          }
        };

        const handleListDragStart = (listId) => setDraggingListId(listId);
        const handleListDragEnter = (e, listId) => { e.preventDefault(); if (dragOverListId !== listId) setDragOverListId(listId); };
        const handleListDragOver = (e) => e.preventDefault();
        const handleListDragLeave = () => {};
        const handleListDrop = (listId) => {
          // If dragging a goal, move it to this list
          if (draggingGoalId) {
            setGoals((prev) => prev.map((g) => g.id === draggingGoalId ? { ...g, listId } : g));
            setDraggingGoalId(null);
            setDragOverGoalId(null);
            setDragOverListId(null);
            return;
          }
          // If dragging a list, reorder lists
          if (!draggingListId || draggingListId === listId) { setDraggingListId(null); setDragOverListId(null); return; }
          setLists((prev) => {
            const from = prev.findIndex((l) => l.id === draggingListId);
            const to = prev.findIndex((l) => l.id === listId);
            if (from === -1 || to === -1) return prev;
            const next = prev.slice();
            const [moved] = next.splice(from, 1);
            next.splice(to, 0, moved);
            return next;
          });
          setDraggingListId(null);
          setDragOverListId(null);
        };

        // Mobile-friendly list reorder via buttons (edit mode)
        const moveListUp = (listId) => {
          setLists((prev) => {
            const i = prev.findIndex((l) => l.id === listId);
            if (i <= 0) return prev;
            const next = prev.slice();
            [next[i - 1], next[i]] = [next[i], next[i - 1]];
            return next;
          });
        };
        const moveListDown = (listId) => {
          setLists((prev) => {
            const i = prev.findIndex((l) => l.id === listId);
            if (i === -1 || i >= prev.length - 1) return prev;
            const next = prev.slice();
            [next[i], next[i + 1]] = [next[i + 1], next[i]];
            return next;
          });
        };

        const handleKeyPress = (e) => {
          if (e.key === 'Enter') {
            addGoal();
          }
        };

        const checkTogglStatus = async () => {
          if (!togglApiToken) return;
          try {
            const res = await fetch(`/api/toggl/current?apiToken=${encodeURIComponent(togglApiToken)}`);
            if (res.ok) {
              const data = await res.json();
              setTogglRunning(data.running);
            }
          } catch (err) {}
        };

        const startTimer = async (goalId, todoText = "") => {
          const now = Date.now();
          const goal = goals.find(g => g.id === goalId);
          const listId = goal?.listId || 'default';
          const listName = lists.find(l => l.id === listId)?.name || '기본함';
          const projectName = listId === 'default' ? null : listName;
          
          const currentSeconds = goal?.totalSeconds || 0;
          const currentH = Math.floor(currentSeconds / 3600);
          const currentM = Math.floor((currentSeconds % 3600) / 60);
          const currentStr = currentH > 0 ? `${currentH}시간 ${currentM}분` : `${currentM}분`;
          
          const targetSeconds = (goal?.targetHours || 0) * 3600;
          const targetH = Math.floor(targetSeconds / 3600);
          const targetM = Math.floor((targetSeconds % 3600) / 60);
          const targetStr = targetH > 0 ? `${targetH}시간 ${targetM}분` : `${targetM}분`;
          
          const progress = targetSeconds > 0 ? Math.min((currentSeconds / targetSeconds) * 100, 100).toFixed(0) : 0;
          
          let description = todoText ? `${goal?.name} - ${todoText}` : (goal?.name || 'Goal Tracker');
          if (togglFormat) {
            const formatted = togglFormat
              .replace('{current}', currentStr)
              .replace('{target}', targetStr)
              .replace('{progress}', progress);
            description += ` ${formatted}`;
          }
          
          const entryId = await TogglIntegration.startTimer(description, projectName);
          if (entryId) setTogglEntryId(entryId);
          
          setActiveTimer(goalId);
          setTimerSeconds(0);
          setTimerStartTime(now);
          setTimerMemo(todoText);
          localStorage.setItem('timer-state', JSON.stringify({
            activeTimer: goalId,
            timerStartTime: now,
            togglEntryId: entryId
          }));
          
          checkTogglStatus();
        };



        const stopTimer = async (goalId) => {
          if (togglEntryId) {
            await TogglIntegration.stopTimer(togglEntryId);
            setTogglEntryId(null);
          }
          
          if (activeTimer === goalId && timerSeconds > 0) {
            const endTime = new Date();
            const startTime = new Date(timerStartTime);
            const isTodoTimer = timerMemo && timerMemo.trim().length > 0;
            setGoals((prevGoals) =>
              prevGoals.map((goal) => {
                if (goal.id === goalId) {
                  const newTotalSeconds = goal.totalSeconds + timerSeconds;
                  return {
                    ...goal,
                    totalSeconds: newTotalSeconds,
                    logs: [
                      {
                        date: new Date().toLocaleDateString("ko-KR"),
                        seconds: timerSeconds,
                        memo: timerMemo || "",
                        startTime: `${String(startTime.getHours()).padStart(2, '0')}:${String(startTime.getMinutes()).padStart(2, '0')}`,
                        endTime: `${String(endTime.getHours()).padStart(2, '0')}:${String(endTime.getMinutes()).padStart(2, '0')}`,
                        fromTodo: isTodoTimer
                      },
                      ...goal.logs
                    ]
                  };
                }
                return goal;
              })
            );
          }
          setActiveTimer(null);
          setTimerSeconds(0);
          setTimerStartTime(null);
          setTimerMemo("");
localStorage.removeItem('timer-state');
          
          checkTogglStatus();
        };

        const deleteGoal = (goalId) => {
          if (!window.confirm("정말로 이 목표를 삭제할까요?")) return;
          setGoals((prevGoals) => prevGoals.filter((goal) => goal.id !== goalId));
        };

        const triggerConfetti = () => {
          const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
          const newConfetti = Array.from({ length: 50 }, (_, i) => ({
            id: Date.now() + i,
            left: Math.random() * 100,
            backgroundColor: colors[Math.floor(Math.random() * colors.length)],
            delay: Math.random() * 0.5
          }));
          setConfetti(newConfetti);
          setTimeout(() => setConfetti([]), 3000);
        };

        const toggleComplete = (goalId) => {
          setGoals((prevGoals) =>
            prevGoals.map((goal) => {
              if (goal.id !== goalId) return goal;
              if (goal.completedAt) {
                return { ...goal, completedAt: null };
              }
              triggerConfetti();
              const incomplete = prevGoals.filter(g => !g.completedAt && g.id !== goalId && getProgress(g) < 100);
              if (incomplete.length > 0) {
                setNextGoalSuggestion(incomplete[0]);
                setTimeout(() => setNextGoalSuggestion(null), 5000);
              }
              return { ...goal, completedAt: new Date().toISOString() };
            })
          );
        };

        const updateGoalName = (goalId, value) => {
          setGoals((prevGoals) =>
            prevGoals.map((goal) => (goal.id === goalId ? { ...goal, name: value } : goal))
          );
        };

        const updateGoalTarget = (goalId, value) => {
          setGoals((prevGoals) =>
            prevGoals.map((goal) => {
              if (goal.id !== goalId) return goal;
              const newTarget = (() => {
                const parsed = parseFloat(value);
                return Number.isFinite(parsed) ? parsed : 0;
              })();
              return {
                ...goal,
                targetHours: newTarget
              };
            })
          );
        };

        const toggleGoalExpanded = useCallback((goalId) => {
          setExpandedGoals((prev) => {
            const next = new Set(prev);
            if (next.has(goalId)) {
              next.delete(goalId);
            } else {
              next.add(goalId);
            }
            return next;
          });
        }, []);

        const toggleExpandedLogs = (goalId) => {
          setExpandedLogsGoals((prev) => {
            const next = new Set(prev);
            if (next.has(goalId)) {
              next.delete(goalId);
            } else {
              next.add(goalId);
            }
            return next;
          });
        };

        const toggleEditingLogs = (goalId) => {
          setEditingLogsGoals((prev) => {
            const next = new Set(prev);
            if (next.has(goalId)) {
              next.delete(goalId);
            } else {
              next.add(goalId);
            }
            return next;
          });
        };

        const toggleExpandedTodos = (goalId) => {
          setExpandedTodos((prev) => {
            const next = new Set(prev);
            if (next.has(goalId)) {
              next.delete(goalId);
            } else {
              next.add(goalId);
            }
            return next;
          });
        };

        const handleLogKeyPress = (e, goalId) => {
          if (e.key === 'Enter') {
            addManualLog(goalId);
          }
        };

        const moveGoalUp = (goalId) => {
          setGoals((prevGoals) => {
            const idx = prevGoals.findIndex((g) => g.id === goalId);
            if (idx <= 0) return prevGoals;
            const next = prevGoals.slice();
            [next[idx - 1], next[idx]] = [next[idx], next[idx - 1]];
            return next;
          });
          // Update selected card index to follow the moved goal
          const sortedIdx = sortedGoals.findIndex((g) => g.id === goalId);
          if (sortedIdx > 0) {
            setSelectedCardIndex(sortedIdx - 1);
          }
        };

        const moveGoalDown = (goalId) => {
          setGoals((prevGoals) => {
            const idx = prevGoals.findIndex((g) => g.id === goalId);
            if (idx === -1 || idx >= prevGoals.length - 1) return prevGoals;
            const next = prevGoals.slice();
            [next[idx], next[idx + 1]] = [next[idx + 1], next[idx]];
            return next;
          });
          // Update selected card index to follow the moved goal
          const sortedIdx = sortedGoals.findIndex((g) => g.id === goalId);
          if (sortedIdx < sortedGoals.length - 1) {
            setSelectedCardIndex(sortedIdx + 1);
          }
        };

        const handleDragStart = (goalId) => {
          setDraggingGoalId(goalId);
        };

        const handleDragEnter = (event, overGoalId) => {
          event.preventDefault();
          const rect = event.currentTarget.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const position = event.clientY < midpoint ? 'before' : 'after';
          setDragOverGoalId(overGoalId);
          setDragPosition(position);
        };

        const handleDragLeave = () => {
          // no-op to keep the indicator stable until drop or drag end
        };

        const handleDrop = (overGoalId) => {
          if (!draggingGoalId || draggingGoalId === overGoalId) {
            setDraggingGoalId(null);
            setDragOverGoalId(null);
            return;
          }
          const draggedGoalSortedIdx = sortedGoals.findIndex((g) => g.id === draggingGoalId);
          setGoals((prevGoals) => {
            const fromIdx = prevGoals.findIndex((g) => g.id === draggingGoalId);
            const toIdx = prevGoals.findIndex((g) => g.id === overGoalId);
            if (fromIdx === -1 || toIdx === -1) return prevGoals;
            const next = prevGoals.slice();
            const [moved] = next.splice(fromIdx, 1);
            let insertIdx = toIdx;
            if (fromIdx < toIdx) insertIdx--; // Adjust for removal
            if (dragPosition === 'after') insertIdx++;
            next.splice(insertIdx, 0, moved);
            return next;
          });
          // Update selected card index to follow the dragged goal
          setTimeout(() => {
            const newSortedIdx = sortedGoals.findIndex((g) => g.id === draggingGoalId);
            if (newSortedIdx >= 0) setSelectedCardIndex(newSortedIdx);
          }, 0);
          setDraggingGoalId(null);
          setDragOverGoalId(null);
        };

        const cancelTimer = async (goalId) => {
          if (activeTimer === goalId) {
            if (togglEntryId) {
              await TogglIntegration.stopTimer(togglEntryId);
              setTogglEntryId(null);
            }
            setActiveTimer(null);
            setTimerSeconds(0);
            setTimerStartTime(null);
            setTimerMemo("");
            localStorage.removeItem('timer-state');
          }
        };

        const updateLogMemo = (goalId, logIndex, newMemo) => {
          setGoals((prevGoals) =>
            prevGoals.map((goal) => {
              if (goal.id !== goalId) return goal;
              const updatedLogs = goal.logs.map((log, idx) =>
                idx === logIndex ? { ...log, memo: newMemo } : log
              );
              return { ...goal, logs: updatedLogs };
            })
          );
        };

        const updateLogTime = (goalId, logIndex, startTime, endTime) => {
          setGoals((prevGoals) =>
            prevGoals.map((goal) => {
              if (goal.id !== goalId) return goal;
              const updatedLogs = goal.logs.map((log, idx) => {
                if (idx !== logIndex) return log;
                if (startTime && endTime) {
                  const [startH, startM] = startTime.split(':').map(Number);
                  const [endH, endM] = endTime.split(':').map(Number);
                  const startMinutes = startH * 60 + startM;
                  const endMinutes = endH * 60 + endM;
                  let newSeconds = (endMinutes - startMinutes) * 60;
                  if (newSeconds < 0) newSeconds += 24 * 3600;
                  return { ...log, startTime, endTime, seconds: newSeconds };
                }
                return { ...log, startTime, endTime };
              });
              const newTotalSeconds = updatedLogs.reduce((sum, log) => sum + log.seconds, 0);
              return { ...goal, logs: updatedLogs, totalSeconds: newTotalSeconds };
            })
          );
        };

        const deleteGoalLog = (goalId, logIndex) => {
          if (!window.confirm("이 기록을 삭제할까요?")) return;
          setGoals((prevGoals) =>
            prevGoals.map((goal) => {
              if (goal.id !== goalId) return goal;
              const removed = goal.logs[logIndex];
              if (!removed) return goal;
              const updatedLogs = goal.logs.filter((_, index) => index !== logIndex);
              const adjustedSeconds = Math.max(goal.totalSeconds - removed.seconds, 0);
              return { ...goal, logs: updatedLogs, totalSeconds: adjustedSeconds };
            })
          );
        };

        const addManualLog = (goalId) => {
          let totalSeconds = 0;
          
          if (newLogStartTime && newLogEndTime) {
            const [startH, startM] = newLogStartTime.split(':').map(Number);
            const [endH, endM] = newLogEndTime.split(':').map(Number);
            const startMinutes = startH * 60 + startM;
            const endMinutes = endH * 60 + endM;
            totalSeconds = (endMinutes - startMinutes) * 60;
            if (totalSeconds < 0) totalSeconds += 24 * 3600;
          } else {
            const hours = parseFloat(newLogHours) || 0;
            const minutes = parseFloat(newLogMinutes) || 0;
            totalSeconds = hours * 3600 + minutes * 60;
          }
          
          if (totalSeconds > 0) {
            const logDate = newLogDate ? new Date(newLogDate).toLocaleDateString("ko-KR") : new Date().toLocaleDateString("ko-KR");
            setGoals((prevGoals) =>
              prevGoals.map((goal) => {
                if (goal.id !== goalId) return goal;
                const newTotalSeconds = goal.totalSeconds + totalSeconds;
                return {
                  ...goal,
                  totalSeconds: newTotalSeconds,
                  logs: [
                    {
                      date: logDate,
                      seconds: totalSeconds,
                      memo: newLogMemo || "",
                      startTime: newLogStartTime || undefined,
                      endTime: newLogEndTime || undefined
                    },
                    ...goal.logs
                  ]
                };
              })
            );
            setNewLogHours("");
            setNewLogMinutes("");
            setNewLogDate("");
            setNewLogMemo("");
            setNewLogStartTime("");
            setNewLogEndTime("");
            setShowAddLog(null);
          }
        };

        const formatTime = (seconds) => {
          const hours = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          const secs = seconds % 60;
          return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        };

        const formatHoursVerbose = (hoursValue) => {
          if (!hoursValue || hoursValue <= 0) return "0초";
          const totalSeconds = Math.round(hoursValue * 3600);
          if (totalSeconds < 60) {
            return `${totalSeconds}초`;
          }
          const totalMinutes = Math.round(totalSeconds / 60);
          if (totalMinutes < 60) {
            return `${totalMinutes}분`;
          }
          const hours = Math.floor(totalSeconds / 3600);
          const remainingMinutes = Math.round((totalSeconds % 3600) / 60);
          if (remainingMinutes === 0) {
            return `${hours}시간`;
          }
          return `${hours}시간 ${remainingMinutes}분`;
        };

        const formatDuration = (secondsValue) => {
          if (!secondsValue || secondsValue <= 0) return "0초";
          const hours = Math.floor(secondsValue / 3600);
          const minutes = Math.floor((secondsValue % 3600) / 60);
          const seconds = secondsValue % 60;
          const parts = [];
          if (hours) parts.push(`${hours}시간`);
          if (minutes) parts.push(`${minutes}분`);
          if (seconds && !hours && !minutes) parts.push(`${seconds}초`);
          return parts.join(" ") || "0초";
        };

        const getProgress = (goal, totalSeconds = goal.totalSeconds) => {
          if (!goal.targetHours) return 0;
          const hours = totalSeconds / 3600;
          return Math.min((hours / goal.targetHours) * 100, 100);
        };

        const getStatus = (goal, totalSeconds = goal.totalSeconds) => {
          if (!goal.targetHours) return "목표를 설정해주세요";
          const hours = totalSeconds / 3600;
          if (hours >= goal.targetHours) return "완료!";
          const remainingHours = goal.targetHours - hours;
          if (remainingHours < 1 / 60) {
            const remainingSeconds = remainingHours * 3600;
            return `${Math.max(remainingSeconds.toFixed(0), 1)}초 남음`;
          }
          if (remainingHours < 1) {
            return `${(remainingHours * 60).toFixed(0)}분 남음`;
          }
          return `${remainingHours.toFixed(1)}시간 남음`;
        };

        // 스트릭 계산 (연속 실행일)
        const getStreak = (goal) => {
          if (!goal.logs || goal.logs.length === 0) return 0;
          
          // 날짜별로 그룹화 (같은 날 여러 기록 = 1일)
          const uniqueDates = [...new Set(goal.logs.map(log => log.date))].sort((a, b) => new Date(b) - new Date(a));
          if (uniqueDates.length === 0) return 0;
          
          let streak = 0;
          let checkDate = new Date();
          
          for (const dateStr of uniqueDates) {
            const expectedDate = checkDate.toLocaleDateString("ko-KR");
            if (dateStr === expectedDate) {
              streak++;
              checkDate.setDate(checkDate.getDate() - 1);
            } else {
              break;
            }
          }
          return streak;
        };

        // 오늘 작업했는지 확인
        const hasWorkedToday = (goal) => {
          if (!goal.logs || goal.logs.length === 0) return false;
          const today = new Date().toLocaleDateString("ko-KR");
          return goal.logs.some(log => log.date === today);
        };

        // 일일 목표 제안 (남은 시간 / 남은 일수)
        const getDailySuggestion = (goal) => {
          if (!goal.targetHours || goal.completedAt) return null;
          const remainingHours = Math.max(0, goal.targetHours - (goal.totalSeconds / 3600));
          if (remainingHours === 0) return null;
          const dailyHours = remainingHours / 30;
          if (dailyHours < 1/60) return "1분";
          if (dailyHours < 1) return `${Math.ceil(dailyHours * 60)}분`;
          return `${dailyHours.toFixed(1)}시간`;
        };

        const getTodayTotalSeconds = () => {
          const today = new Date().toLocaleDateString("ko-KR");
          return filteredGoals.reduce((total, goal) => {
            const todayLogs = goal.logs.filter(log => log.date === today);
            return total + todayLogs.reduce((sum, log) => sum + log.seconds, 0);
          }, 0) + (activeTimer ? timerSeconds : 0);
        };

        const getWeeklyStats = () => {
          const now = new Date();
          const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          let totalSeconds = 0;
          const goalStats = {};
          const listStats = {};
          goals.forEach(goal => {
            goal.logs.forEach(log => {
              const logDate = new Date(log.date);
              if (logDate >= weekAgo) {
                totalSeconds += log.seconds;
                goalStats[goal.name] = (goalStats[goal.name] || 0) + log.seconds;
                const listId = goal.listId || 'default';
                const listName = lists.find(l => l.id === listId)?.name || '기본함';
                listStats[listName] = (listStats[listName] || 0) + log.seconds;
              }
            });
          });
          const topGoal = Object.entries(goalStats).sort((a, b) => b[1] - a[1])[0];
          const sortedLists = Object.entries(listStats).sort((a, b) => b[1] - a[1]);
          return { totalSeconds, topGoal: topGoal ? { name: topGoal[0], seconds: topGoal[1] } : null, listStats: sortedLists };
        };

        const getAchievementBadge = (goal) => {
          const progress = getProgress(goal);
          if (progress >= 100) return '🥇';
          if (progress >= 80) return '🥈';
          return null;
        };

        const getTotalHours = () => goals.reduce((sum, g) => sum + g.totalSeconds / 3600, 0);
        const getLevel = () => Math.floor(getTotalHours() / 10) + 1;
        const getLevelProgress = () => (getTotalHours() % 10) / 10 * 100;
        
        const getBadges = () => {
          const badges = [];
          const totalHours = getTotalHours();
          if (totalHours >= 100) badges.push({ icon: '💯', name: '100시간 달성' });
          if (totalHours >= 50) badges.push({ icon: '⭐', name: '50시간 달성' });
          if (totalHours >= 10) badges.push({ icon: '🌟', name: '10시간 달성' });
          const maxStreak = Math.max(...goals.map(g => getStreak(g)));
          if (maxStreak >= 7) badges.push({ icon: '🔥', name: '7일 연속' });
          if (maxStreak >= 30) badges.push({ icon: '🏆', name: '30일 연속' });
          const completed = goals.filter(g => g.completedAt).length;
          if (completed >= 10) badges.push({ icon: '🎯', name: '10개 완료' });
          if (completed >= 5) badges.push({ icon: '✅', name: '5개 완료' });
          return badges;
        };
        
        const getHeatmapData = () => {
          const data = {};
          const today = new Date();
          for (let i = 29; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toLocaleDateString('ko-KR');
            data[dateStr] = 0;
          }
          goals.forEach(g => {
            g.logs.forEach(log => {
              if (data[log.date] !== undefined) {
                data[log.date] += log.seconds / 3600;
              }
            });
          });
          return data;
        };

        const filteredGoals = goals.filter((g) => (g.listId || "default") === (selectedListId || "default"));
        const sortedGoals = filteredGoals;
        
        const todayPendingGoals = filteredGoals.filter(g => !hasWorkedToday(g) && !g.completedAt && getProgress(g) < 100);

        const handleContextMenu = (e, goalId) => {
          e.preventDefault();
          setContextMenu({ x: e.clientX, y: e.clientY, goalId });
        };

        const handleListContextMenu = (e, listId) => {
          e.preventDefault();
          setListContextMenu({ x: e.clientX, y: e.clientY, listId });
        };

        useEffect(() => {
          const handleClick = () => {
            setContextMenu(null);
            setListContextMenu(null);
            setTodoContextMenu(null);
            setLogContextMenu(null);
            setEditingLogIndex(null);
            setShowDropboxMenu(false);
          };
          document.addEventListener('click', handleClick);
          return () => document.removeEventListener('click', handleClick);
        }, []);

        useEffect(() => {
          const currentListIdx = lists.findIndex(l => l.id === selectedListId);
          if (currentListIdx >= 0) setSelectedListIndex(currentListIdx);
        }, [selectedListId, lists]);

        useEffect(() => {
          const handleKeyDown = (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
              if (e.key === 'Escape') {
                e.target.blur();
                setSelectedFieldIndex(-1);
              } else if (e.key === 'ArrowDown' && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                e.preventDefault();
                e.target.blur();
                if (e.target.id === 'new-list-input') {
                  setSidebarFocused(true);
                  setSelectedListIndex(0);
                } else {
                  setSelectedCardIndex(0);
                }
              }
              return;
            }

            if (sidebarFocused) {
              if (e.key === 'ArrowDown') {
                e.preventDefault();
                setSelectedListIndex((prev) => Math.min(lists.length - 1, prev + 1));
              } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedListIndex === 0) {
                  const input = document.querySelector('#new-list-input');
                  if (input) {
                    input.focus();
                    setSidebarFocused(false);
                    setSelectedListIndex(-1);
                    setSelectedCardIndex(-1);
                  }
                } else {
                  setSelectedListIndex((prev) => prev - 1);
                }
              } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                setSidebarFocused(false);
                if (selectedCardIndex < 0 && sortedGoals.length > 0) {
                  setSelectedCardIndex(0);
                }
              } else if (e.key === 'Enter') {
                e.preventDefault();
                if (lists[selectedListIndex]) {
                  setSelectedListId(lists[selectedListIndex].id);
                }
              } else if (e.altKey && e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedListIndex > 0) {
                  moveListUp(lists[selectedListIndex]?.id);
                  setSelectedListIndex((prev) => prev - 1);
                }
              } else if (e.altKey && e.key === 'ArrowDown') {
                e.preventDefault();
                if (selectedListIndex < lists.length - 1) {
                  moveListDown(lists[selectedListIndex]?.id);
                  setSelectedListIndex((prev) => prev + 1);
                }
              } else if (e.key === 'Delete') {
                e.preventDefault();
                if (lists[selectedListIndex]) deleteList(lists[selectedListIndex].id);
              } else if (e.key === 'Escape') {
                e.preventDefault();
                setSidebarFocused(false);
              }
              return;
            }

            if (e.ctrlKey && e.key === 'z') {
              e.preventDefault();
              undo();
              return;
            }

            if (e.ctrlKey && e.key === 'y') {
              e.preventDefault();
              redo();
              return;
            }

            if (e.ctrlKey && e.code === 'Space') {
              e.preventDefault();
              if (sortedGoals[selectedCardIndex]) {
                const goal = sortedGoals[selectedCardIndex];
                if (activeTimer === goal.id) {
                  stopTimer(goal.id);
                } else {
                  startTimer(goal.id);
                }
              }
              return;
            }

            if (e.ctrlKey && e.key === 'Enter') {
              e.preventDefault();
              if (sortedGoals[selectedCardIndex]) {
                toggleComplete(sortedGoals[selectedCardIndex].id);
              }
              return;
            }

            if (selectedFieldIndex >= 0) {
              if (e.key === 'ArrowLeft') {
                e.preventDefault();
                setSelectedFieldIndex(Math.max(0, selectedFieldIndex - 1));
              } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const goal = sortedGoals[selectedCardIndex];
                const displayedLogs = (expandedLogsGoals.has(goal?.id) || editingLogsGoals.has(goal?.id)) ? goal?.logs : goal?.logs?.slice(-6);
                const logCount = displayedLogs?.length || 0;
                let maxField = 5 + logCount;
                if (goal?.logs?.length > 6 && !expandedLogsGoals.has(goal?.id)) maxField++;
                setSelectedFieldIndex(Math.min(maxField, selectedFieldIndex + 1));
              } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                const goal = sortedGoals[selectedCardIndex];
                const displayedLogs = (expandedLogsGoals.has(goal?.id) || editingLogsGoals.has(goal?.id)) ? goal?.logs : goal?.logs?.slice(-6);
                const logCount = displayedLogs?.length || 0;
                let maxField = 5 + logCount;
                if (goal?.logs?.length > 6 && !expandedLogsGoals.has(goal?.id)) maxField++;
                if (selectedFieldIndex < maxField) {
                  setSelectedFieldIndex((prev) => prev + 1);
                }
              } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (selectedFieldIndex > 0) {
                  setSelectedFieldIndex((prev) => prev - 1);
                }
              } else if (e.key === 'Enter') {
                e.preventDefault();
                const goal = sortedGoals[selectedCardIndex];
                if (!goal) return;
                if (selectedFieldIndex === 0) {
                  setEditingGoalName(goal.id);
                  setTimeout(() => {
                    const el = document.querySelector(`[data-goal-name="${goal.id}"]`);
                    if (el) { el.focus(); const range = document.createRange(); range.selectNodeContents(el); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }
                  }, 0);
                } else if (selectedFieldIndex === 1) {
                  setEditingTargetHours(goal.id);
                  setTimeout(() => {
                    const el = document.querySelector(`[data-goal-hours="${goal.id}"]`);
                    if (el) { el.focus(); const range = document.createRange(); range.selectNodeContents(el); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }
                  }, 0);
                } else if (selectedFieldIndex === 2) {
                  setTimeout(() => {
                    const el = document.querySelector(`[data-goal-minutes="${goal.id}"]`);
                    if (el) { el.focus(); const range = document.createRange(); range.selectNodeContents(el); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }
                  }, 0);
                } else if (selectedFieldIndex === 3) {
                  deleteGoal(goal.id);
                } else if (selectedFieldIndex === 4) {
                  if (activeTimer === goal.id) stopTimer(goal.id); else startTimer(goal.id);
                } else if (selectedFieldIndex === 5) {
                  setShowAddLog(goal.id);
                } else if (selectedFieldIndex >= 6) {
                  const displayedLogs = (expandedLogsGoals.has(goal.id) || editingLogsGoals.has(goal.id)) ? goal.logs : goal.logs.slice(-6);
                  const logIndex = selectedFieldIndex - 6;
                  if (logIndex < displayedLogs.length) {
                    const originalIndex = goal.logs.indexOf(displayedLogs[logIndex]);
                    setEditingLogIndex(`${goal.id}-${originalIndex}`);
                    setEditLogMemo(goal.logs[originalIndex]?.memo || "");
                  } else {
                    toggleExpandedLogs(goal.id);
                  }
                }
              } else if (e.key === 'Escape') {
                e.preventDefault();
                setSelectedFieldIndex(-1);
              }
              return;
            }

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              const activeEl = document.activeElement;
              if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
                activeEl.blur();
              }
              setSelectedCardIndex((prev) => Math.min(sortedGoals.length - 1, prev + 1));
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              if (selectedCardIndex === 0) {
                const input = document.querySelector('input[placeholder="목표 이름"]');
                if (input) {
                  input.focus();
                  setSelectedCardIndex(-1);
                }
              } else {
                setSelectedCardIndex((prev) => Math.max(0, prev - 1));
              }
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              setSidebarFocused(true);
              if (selectedListIndex < 0) {
                const currentListIdx = lists.findIndex(l => l.id === selectedListId);
                setSelectedListIndex(currentListIdx >= 0 ? currentListIdx : 0);
              }
            } else if (e.key === 'Enter') {
              e.preventDefault();
              setSelectedFieldIndex(0);
            } else if (e.key === 'Delete') {
              e.preventDefault();
              if (sortedGoals[selectedCardIndex]) deleteGoal(sortedGoals[selectedCardIndex].id);
            }
          };
          document.addEventListener('keydown', handleKeyDown);
          return () => document.removeEventListener('keydown', handleKeyDown);
        }, [selectedCardIndex, selectedFieldIndex, sortedGoals, activeTimer, sidebarFocused, selectedListIndex, lists, selectedListId]);

        useEffect(() => {
          if (cardRefs.current[selectedCardIndex]) {
            cardRefs.current[selectedCardIndex].scrollIntoView({ behavior: 'auto', block: 'center' });
          }
        }, [selectedCardIndex]);

        useEffect(() => {
          if (sidebarFocused && selectedListIndex >= 0) {
            const listEl = document.querySelectorAll('.sidebar-list-item')[selectedListIndex];
            if (listEl) {
              listEl.scrollIntoView({ behavior: 'auto', block: 'nearest' });
            }
          }
        }, [sidebarFocused, selectedListIndex]);

        useEffect(() => {
          if (persistence.statusMessage && (persistence.statusMessage.includes('✓') || persistence.statusMessage.includes('✗'))) {
            setShowToast(true);
            if (toastTimeoutRef.current) clearTimeout(toastTimeoutRef.current);
            toastTimeoutRef.current = setTimeout(() => setShowToast(false), 2000);
          }
        }, [persistence.statusMessage]);

        return (
          <div className="min-h-screen bg-black p-0 sm:p-5">
            {confetti.map(c => (
              <div
                key={c.id}
                className="confetti"
                style={{
                  left: `${c.left}%`,
                  backgroundColor: c.backgroundColor,
                  animationDelay: `${c.delay}s`
                }}
              />
            ))}
            {nextGoalSuggestion && (
              <div className="fixed bottom-4 left-4 right-4 sm:left-auto sm:right-4 z-[60] bg-gradient-to-r from-blue-500 to-purple-500 text-white px-4 py-3 rounded-lg shadow-lg max-w-sm mx-auto sm:mx-0">
                <div className="flex items-center justify-between gap-2">
                  <div>
                    <p className="text-sm font-semibold">🎉 목표 달성!</p>
                    <p className="text-xs mt-1">다음은 "{nextGoalSuggestion.name}" 어떠세요?</p>
                  </div>
                  <button onClick={() => setNextGoalSuggestion(null)} className="text-white/80 hover:text-white">✕</button>
                </div>
              </div>
            )}
            {showTimeline && (() => {
              document.body.style.overflow = 'hidden';
              
              const days = [];
              for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = date.toLocaleDateString("ko-KR");
                const dayLogs = [];
                goals.forEach(goal => {
                  goal.logs.forEach(log => {
                    if (log.date === dateStr) {
                      dayLogs.push({ ...log, goalName: goal.name, goalId: goal.id });
                    }
                  });
                });
                days.push({ date: dateStr, logs: dayLogs });
              }
              
              const getMonthDays = () => {
                const year = calendarDate.getFullYear();
                const month = calendarDate.getMonth();
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const startDay = firstDay.getDay();
                const daysInMonth = lastDay.getDate();
                
                const monthDays = [];
                for (let i = 0; i < startDay; i++) monthDays.push(null);
                for (let i = 1; i <= daysInMonth; i++) {
                  const date = new Date(year, month, i);
                  const dateStr = date.toLocaleDateString("ko-KR");
                  const dayLogs = [];
                  goals.forEach(goal => {
                    goal.logs.forEach(log => {
                      if (log.date === dateStr) {
                        dayLogs.push({ ...log, goalName: goal.name, goalId: goal.id });
                      }
                    });
                  });
                  monthDays.push({ date: dateStr, day: i, logs: dayLogs });
                }
                return monthDays;
              };
              
              goals.forEach(g => {
                if (!goalColors.current[g.id]) {
                  goalColors.current[g.id] = availableColors[Object.keys(goalColors.current).length % availableColors.length];
                }
              });
              return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 overflow-y-auto" onClick={() => setShowTimeline(false)}>
                  <div className="bg-gray-800 rounded-lg max-w-2xl w-full max-h-[90vh] flex flex-col my-auto" onClick={(e) => e.stopPropagation()}>
                    <div className="flex items-center justify-between p-4 border-b border-gray-700">
                      <h2 className="text-sm font-bold text-white">📅 최근 7일 {timelineView === 'timeline' ? '타임라인' : '캘린더'}</h2>
                      <div className="flex gap-2">
                        <button onClick={() => setTimelineView('timeline')} className={`px-2 py-1 rounded text-xs ${timelineView === 'timeline' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}>타임라인</button>
                        <button onClick={() => setTimelineView('calendar')} className={`px-2 py-1 rounded text-xs ${timelineView === 'calendar' ? 'bg-blue-500 text-white' : 'bg-gray-700 text-gray-300'}`}>캘린더</button>
                      </div>
                    </div>
                    {timelineView === 'timeline' ? (
                    <div className="space-y-4 overflow-y-auto flex-1 p-4">
                      {days.map(day => (
                        <div key={day.date} className="bg-gray-900 rounded p-2">
                          <div className="text-sm font-semibold text-gray-200 mb-2">{day.date}</div>
                          {day.logs.length === 0 ? (
                            <div className="text-xs text-gray-500 text-center py-2">기록 없음</div>
                          ) : (
                            <div className="space-y-1 max-h-40 overflow-y-auto">
                              {day.logs.map((log, idx) => {
                                let durationText = '';
                                if (log.startTime && log.endTime) {
                                  const [startH, startM] = log.startTime.split(':').map(Number);
                                  const [endH, endM] = log.endTime.split(':').map(Number);
                                  const durationMinutes = (endH * 60 + endM) - (startH * 60 + startM);
                                  durationText = durationMinutes >= 60 
                                    ? `${Math.floor(durationMinutes / 60)}h ${durationMinutes % 60}m`
                                    : `${durationMinutes}m`;
                                } else {
                                  const hours = Math.floor(log.seconds / 3600);
                                  const mins = Math.floor((log.seconds % 3600) / 60);
                                  durationText = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                }
                                return (
                                  <div
                                    key={idx}
                                    className="flex items-center gap-2 text-xs p-1.5 rounded"
                                    style={{ backgroundColor: `${goalColors.current[log.goalId]}20`, borderLeft: `3px solid ${goalColors.current[log.goalId]}` }}
                                  >
                                    {log.startTime && log.endTime ? (
                                      <>
                                        <span className="text-gray-400 font-mono text-[10px] whitespace-nowrap">{log.startTime}</span>
                                        <span className="text-gray-500 text-[10px]">→</span>
                                        <span className="text-gray-400 font-mono text-[10px] whitespace-nowrap">{log.endTime}</span>
                                      </>
                                    ) : null}
                                    <span className="text-gray-500 text-[10px]" style={{ color: goalColors.current[log.goalId] }}>({durationText})</span>
                                    <span className="font-semibold" style={{ color: goalColors.current[log.goalId] }}>{log.goalName}</span>
                                    {log.memo && <span className="text-gray-400 text-[10px] truncate">- {log.memo}</span>}
                                  </div>
                                );
                              })}
                            </div>
                          )}
                        </div>
                      ))}
                    </div>
                    ) : (
                    <div className="overflow-y-auto flex-1 p-4 grid grid-cols-1 lg:grid-cols-2 gap-4">
                      <div>
                      <div className="flex items-center justify-between mb-4">
                        <button onClick={() => setCalendarDate(new Date(calendarDate.getFullYear(), calendarDate.getMonth() - 1))} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm">◀</button>
                        <div className="flex items-center gap-2">
                          <span className="text-white font-semibold">{calendarDate.getFullYear()}년 {calendarDate.getMonth() + 1}월</span>
                          <button onClick={() => setCalendarDate(new Date())} className="px-2 py-1 bg-blue-500 hover:bg-blue-400 text-white rounded text-xs">오늘</button>
                        </div>
                        <button onClick={() => setCalendarDate(new Date(calendarDate.getFullYear(), calendarDate.getMonth() + 1))} className="px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded text-sm">▶</button>
                      </div>
                      <div className="grid grid-cols-7 gap-1 mb-2">
                        {['일', '월', '화', '수', '목', '금', '토'].map((d, i) => <div key={i} className={`text-center text-xs font-semibold ${i === 0 ? 'text-red-400' : i === 6 ? 'text-blue-400' : 'text-gray-400'}`}>{d}</div>)}
                      </div>
                      <div className="grid grid-cols-7 gap-1">
                        {getMonthDays().map((day, idx) => {
                          if (!day) return <div key={`empty-${idx}`} className="aspect-square" />;
                          const totalSeconds = day.logs.reduce((sum, log) => sum + log.seconds, 0);
                          const totalHours = totalSeconds / 3600;
                          const isToday = day.date === new Date().toLocaleDateString("ko-KR");
                          const isSelected = selectedDate === day.date;
                          return (
                            <div key={day.date} onClick={() => setSelectedDate(isSelected ? null : day.date)} className={`h-16 bg-gray-900 rounded p-1 cursor-pointer hover:bg-gray-800 transition ${isToday ? 'ring-2 ring-blue-400' : ''} ${isSelected ? 'ring-2 ring-yellow-400' : ''}`}>
                              <div className="text-xs text-gray-300 mb-0.5">{day.day}</div>
                              <div className="text-xs font-bold text-cyan-400">{totalHours > 0 ? `${totalHours.toFixed(1)}h` : ''}</div>
                              <div className="text-xs text-gray-500">{day.logs.length > 0 ? `${day.logs.length}개` : ''}</div>
                            </div>
                          );
                        })}
                      </div>
                      </div>
                      <div className="lg:block">
                      {selectedDate ? (() => {
                        const dayData = getMonthDays().find(d => d?.date === selectedDate);
                        if (!dayData) return null;
                        return (
                          <div className="mt-4 bg-gray-900 rounded p-3">
                            <div className="text-sm font-semibold text-white mb-2">{selectedDate}</div>
                            {dayData.logs.length === 0 ? (
                              <div className="text-xs text-gray-500 text-center py-2">기록 없음</div>
                            ) : (
                              <div className="space-y-1 max-h-40 overflow-y-auto">
                                {dayData.logs.map((log, idx) => {
                                  let durationText = '';
                                  if (log.startTime && log.endTime) {
                                    const [startH, startM] = log.startTime.split(':').map(Number);
                                    const [endH, endM] = log.endTime.split(':').map(Number);
                                    const durationMinutes = (endH * 60 + endM) - (startH * 60 + startM);
                                    durationText = durationMinutes >= 60 ? `${Math.floor(durationMinutes / 60)}h ${durationMinutes % 60}m` : `${durationMinutes}m`;
                                  } else {
                                    const hours = Math.floor(log.seconds / 3600);
                                    const mins = Math.floor((log.seconds % 3600) / 60);
                                    durationText = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                  }
                                  return (
                                    <div key={idx} className="flex items-center gap-2 text-xs p-1.5 rounded" style={{ backgroundColor: `${goalColors.current[log.goalId]}20`, borderLeft: `3px solid ${goalColors.current[log.goalId]}` }}>
                                      {log.startTime && log.endTime && (
                                        <>
                                          <span className="text-gray-400 font-mono text-[10px] whitespace-nowrap">{log.startTime}</span>
                                          <span className="text-gray-500 text-[10px]">→</span>
                                          <span className="text-gray-400 font-mono text-[10px] whitespace-nowrap">{log.endTime}</span>
                                        </>
                                      )}
                                      <span className="text-gray-500 text-[10px]" style={{ color: goalColors.current[log.goalId] }}>({durationText})</span>
                                      <span className="font-semibold" style={{ color: goalColors.current[log.goalId] }}>{log.goalName}</span>
                                      {log.memo && <span className="text-gray-400 text-[10px] truncate">- {log.memo}</span>}
                                    </div>
                                  );
                                })}
                              </div>
                            )}
                          </div>
                        );
                      })() : <div className="text-center text-gray-500 text-sm py-8">날짜를 선택하세요</div>}
                      </div>
                    </div>
                    )}
                    <div className="p-4 border-t border-gray-700">
                      <button onClick={() => { document.body.style.overflow = ''; setShowTimeline(false); }} className="w-full px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition">닫기</button>
                    </div>
                  </div>
                </div>
              );
            })()}
            {showCompactTodos && (
              <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={() => setShowCompactTodos(false)}>
                <div className="bg-gray-800 rounded-lg p-4 max-w-2xl w-full max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                  <h2 className="text-sm font-bold text-white mb-3">✓ 할일 목록</h2>
                  <div className="space-y-3">
                    {filteredGoals.filter(g => g.todos && g.todos.length > 0).map(goal => (
                      <div key={goal.id} className="bg-gray-900 rounded p-3">
                        <div className="flex items-center justify-between mb-2">
                          <span className="text-sm font-semibold text-white">{goal.name}</span>
                          <span className="text-xs text-gray-400">{goal.todos.filter(t => !t.done).length}/{goal.todos.length}</span>
                        </div>
                        <div className="space-y-1">
                          {goal.todos.map(todo => (
                            <div key={todo.id} className="flex items-center gap-2 text-xs" style={{ marginLeft: `${(todo.indent || 0) * 12}px` }}>
                              <input type="checkbox" checked={todo.done} onChange={() => {
                                if (!todo.done) {
                                  const actualSeconds = (todo.estimatedMinutes || 0) * 60;
                                  setGoals((prev) => prev.map((g) => {
                                    if (g.id === goal.id) {
                                      return {
                                        ...g,
                                        todos: g.todos.filter(t => t.id !== todo.id),
                                        logs: [{ date: new Date().toLocaleDateString("ko-KR"), seconds: actualSeconds, memo: todo.text, fromTodo: true, estimated: todo.estimatedMinutes }, ...g.logs]
                                      };
                                    }
                                    return g;
                                  }));
                                } else {
                                  setGoals((prev) => prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, done: !t.done } : t) } : g));
                                }
                              }} className="w-3 h-3" />
                              {todo.estimatedMinutes && <span className="text-blue-400 text-[10px]">{todo.estimatedMinutes}분</span>}
                              <span className={`flex-1 ${todo.done ? 'line-through text-gray-500' : 'text-gray-300'}`}>{todo.text}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    ))}
                    {filteredGoals.filter(g => g.todos && g.todos.length > 0).length === 0 && (
                      <div className="text-center text-gray-500 text-sm py-8">할일이 없습니다</div>
                    )}
                  </div>
                  <button onClick={() => setShowCompactTodos(false)} className="mt-3 w-full px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition">닫기</button>
                </div>
              </div>
            )}
            {showStats && (() => {
              const heatmap = getHeatmapData();
              const level = getLevel();
              const levelProgress = getLevelProgress();
              const badges = getBadges();
              return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={() => setShowStats(false)}>
                  <div className="bg-gray-800 rounded-lg p-4 max-w-2xl w-full max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                    <h2 className="text-sm font-bold text-white mb-3">🏆 통계 & 배지</h2>
                    <div className="space-y-4">
                      <div className="bg-gray-900 rounded p-3">
                        <div className="flex items-center justify-between mb-2">
                          <span className="text-sm text-gray-300">레벨 {level}</span>
                          <span className="text-xs text-gray-400">{getTotalHours().toFixed(1)}시간</span>
                        </div>
                        <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                          <div className="h-full bg-gradient-to-r from-yellow-500 to-orange-500" style={{ width: `${levelProgress}%` }} />
                        </div>
                        <p className="text-xs text-gray-500 mt-1">다음 레벨까지 {(10 - (getTotalHours() % 10)).toFixed(1)}시간</p>
                      </div>
                      <div>
                        <h3 className="text-xs font-semibold text-gray-300 mb-2">배지 ({badges.length})</h3>
                        <div className="grid grid-cols-3 gap-2">
                          {badges.map((badge, i) => (
                            <div key={i} className="bg-gray-900 rounded p-2 text-center">
                              <div className="text-2xl mb-1">{badge.icon}</div>
                              <div className="text-xs text-gray-300">{badge.name}</div>
                            </div>
                          ))}
                        </div>
                      </div>
                      <div>
                        <h3 className="text-xs font-semibold text-gray-300 mb-2">최근 30일 활동</h3>
                        <div className="grid grid-cols-10 gap-1">
                          {Object.entries(heatmap).map(([date, hours]) => {
                            const intensity = hours === 0 ? 0 : hours < 0.5 ? 1 : hours < 1 ? 2 : hours < 2 ? 3 : hours < 4 ? 4 : 5;
                            const colors = ['bg-gray-700', 'bg-green-800', 'bg-green-600', 'bg-green-500', 'bg-green-400', 'bg-green-300'];
                            const day = new Date(date).getDate();
                            return (
                              <div key={date} className="flex flex-col items-center">
                                <div className="text-xs text-gray-500">{day}</div>
                                <div className={`w-7 h-5 rounded ${colors[intensity]} flex items-center justify-center`}>
                                  {hours > 0 && <span className="text-xs text-gray-900 font-semibold">{hours.toFixed(1)}</span>}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                        <div className="flex items-center justify-end gap-2 mt-2 text-xs text-gray-500">
                          <span>0h</span>
                          <div className="w-3 h-3 rounded bg-gray-700"></div>
                          <div className="w-3 h-3 rounded bg-green-800"></div>
                          <div className="w-3 h-3 rounded bg-green-600"></div>
                          <div className="w-3 h-3 rounded bg-green-500"></div>
                          <div className="w-3 h-3 rounded bg-green-400"></div>
                          <div className="w-3 h-3 rounded bg-green-300"></div>
                          <span>4h+</span>
                        </div>
                      </div>
                    </div>
                    <button onClick={() => setShowStats(false)} className="mt-3 w-full px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition">닫기</button>
                  </div>
                </div>
              );
            })()}
            {showWeeklyReport && (() => {
              const stats = getWeeklyStats();
              const now = new Date();
              const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
              const dateRange = `${weekAgo.toLocaleDateString('ko-KR', {month: 'numeric', day: 'numeric'})} ~ ${now.toLocaleDateString('ko-KR', {month: 'numeric', day: 'numeric'})}`;
              return (
                <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={() => setShowWeeklyReport(false)}>
                  <div className="bg-gray-800 rounded-lg p-4 max-w-md w-full" onClick={(e) => e.stopPropagation()}>
                    <h2 className="text-sm font-bold text-white mb-1">📊 주간 리포트</h2>
                    <p className="text-xs text-gray-400 mb-3">{dateRange}</p>
                    <div className="space-y-2">
                      <div>
                        <p className="text-gray-400 text-xs">총 작업 시간</p>
                        <p className="text-base font-bold text-cyan-400">{formatDuration(stats.totalSeconds)}</p>
                      </div>
                      {stats.topGoal && (
                        <div>
                          <p className="text-gray-400 text-xs">가장 많이 한 목표</p>
                          <p className="text-sm font-semibold text-blue-400">{stats.topGoal.name}</p>
                          <p className="text-xs text-gray-500">{formatDuration(stats.topGoal.seconds)}</p>
                        </div>
                      )}
                      {stats.listStats.length > 0 && (
                        <div>
                          <p className="text-gray-400 text-xs mb-1">리스트별 작업 시간</p>
                          <div className="space-y-1">
                            {stats.listStats.map(([listName, seconds]) => (
                              <div key={listName} className="flex justify-between items-center text-xs">
                                <span className="text-gray-300">{listName}</span>
                                <span className="text-purple-400 font-semibold">{formatDuration(seconds)}</span>
                              </div>
                            ))}
                          </div>
                        </div>
                      )}
                    </div>
                    <button onClick={() => setShowWeeklyReport(false)} className="mt-3 w-full px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition">닫기</button>
                  </div>
                </div>
              );
            })()}
            {contextMenu && (
              <div
                className="fixed bg-gray-800 border border-gray-700 rounded-lg shadow-lg py-1 z-50"
                style={{ left: contextMenu.x, top: contextMenu.y }}
              >
                {activeTimer === contextMenu.goalId ? (
                  <button
                    onClick={() => {
                      cancelTimer(contextMenu.goalId);
                      setContextMenu(null);
                    }}
                    className="w-full px-3 py-1.5 text-left text-sm text-gray-200 hover:bg-gray-700 transition"
                  >
                    취소
                  </button>
                ) : (
                  <button
                    onClick={() => {
                      startTimer(contextMenu.goalId);
                      setContextMenu(null);
                    }}
                    className="w-full px-3 py-1.5 text-left text-sm text-gray-200 hover:bg-gray-700 transition"
                  >
                    시작
                  </button>
                )}
                <button
                  onClick={() => {
                    toggleComplete(contextMenu.goalId);
                    setContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-gray-200 hover:bg-gray-700 transition"
                >
                  {(() => {
                    const goal = goals.find(g => g.id === contextMenu.goalId);
                    return goal?.completedAt ? "완료 취소" : "완료";
                  })()}
                </button>
                <button
                  onClick={() => {
                    setShowAddLog(contextMenu.goalId);
                    setContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-gray-200 hover:bg-gray-700 transition"
                >
                  기록 추가
                </button>
                <button
                  onClick={() => {
                    deleteGoal(contextMenu.goalId);
                    setContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-red-400 hover:bg-gray-700 transition"
                >
                  삭제
                </button>
              </div>
            )}
            {listContextMenu && (
              <div
                className="fixed bg-gray-800 border border-gray-700 rounded-lg shadow-lg py-1 z-50"
                style={{ left: listContextMenu.x, top: listContextMenu.y }}
              >
                <button
                  onClick={() => {
                    deleteList(listContextMenu.listId);
                    setListContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-red-400 hover:bg-gray-700 transition"
                >
                  삭제
                </button>
              </div>
            )}
            {todoContextMenu && (
              <div
                className="fixed bg-gray-800 border border-gray-700 rounded-lg shadow-lg py-1 z-50"
                style={{ left: todoContextMenu.x, top: todoContextMenu.y }}
              >
                <button
                  onClick={() => {
                    setGoals((prev) => prev.map((g) => g.id === todoContextMenu.goalId ? { ...g, todos: g.todos.filter((t) => t.id !== todoContextMenu.todoId) } : g));
                    setTodoContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-red-400 hover:bg-gray-700 transition"
                >
                  할일 삭제
                </button>
              </div>
            )}
            {logContextMenu && (
              <div
                className="fixed bg-gray-800 border border-gray-700 rounded-lg shadow-lg py-1 z-50"
                style={{ left: logContextMenu.x, top: logContextMenu.y }}
              >
                {(() => {
                  const goal = goals.find(g => g.id === logContextMenu.goalId);
                  const log = goal?.logs[logContextMenu.logIndex];
                  return log?.fromTodo && (
                    <button
                      onClick={() => {
                        if (window.confirm('이 기록을 할일로 되돌릴까요?')) {
                          setGoals((prev) => prev.map((g) => {
                            if (g.id === logContextMenu.goalId) {
                              const log = g.logs[logContextMenu.logIndex];
                              return {
                                ...g,
                                todos: [...(g.todos || []), { id: Date.now(), text: log.memo, done: false }],
                                logs: g.logs.filter((_, idx) => idx !== logContextMenu.logIndex)
                              };
                            }
                            return g;
                          }));
                        }
                        setLogContextMenu(null);
                      }}
                      className="w-full px-3 py-1.5 text-left text-sm text-blue-400 hover:bg-gray-700 transition"
                    >
                      할일로 되돌리기
                    </button>
                  );
                })()}
                <button
                  onClick={() => {
                    deleteGoalLog(logContextMenu.goalId, logContextMenu.logIndex);
                    setLogContextMenu(null);
                  }}
                  className="w-full px-3 py-1.5 text-left text-sm text-red-400 hover:bg-gray-700 transition"
                >
                  기록 삭제
                </button>
              </div>
            )}
            {showToast && (
              <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50 bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg text-sm">
                {persistence.statusMessage}
              </div>
            )}

            {showTogglSettings && (
              <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={() => setShowTogglSettings(false)}>
                <div className="bg-gray-800 rounded-lg p-4 max-w-md w-full" onClick={(e) => e.stopPropagation()}>
                  <h2 className="text-sm font-bold text-white mb-3">⏱️ Toggl 설정</h2>
                  <div className="space-y-3">
                    <div>
                      <label className="text-xs text-gray-400 block mb-1">API 토큰</label>
                      <input
                        type="password"
                        value={togglApiToken}
                        onChange={(e) => setTogglApiToken(e.target.value)}
                        placeholder="Toggl API 토큰 입력"
                        className="w-full px-2 py-1.5 bg-gray-700 text-gray-100 rounded border border-gray-600 focus:outline-none focus:border-blue-400 text-sm"
                      />
                      <p className="text-xs text-gray-500 mt-1">Toggl → Profile → API Token</p>
                    </div>
                    <div>
                      <label className="text-xs text-gray-400 block mb-1">표시 형식</label>
                      <input
                        type="text"
                        value={togglFormat}
                        onChange={(e) => setTogglFormat(e.target.value)}
                        placeholder="( {current} / {target} | {progress}% )"
                        className="w-full px-2 py-1.5 bg-gray-700 text-gray-100 rounded border border-gray-600 focus:outline-none focus:border-blue-400 text-sm"
                      />
                      <p className="text-xs text-gray-500 mt-1">"{'{current}'}" "{'{target}'}" "{'{progress}'}" 사용 가능. 비워두면 표시 안함</p>
                    </div>
                    <div className="flex gap-2">
                      <button
                        onClick={() => {
                          TogglIntegration.setApiToken(togglApiToken);
                          localStorage.setItem('toggl_format', togglFormat);
                          const payload = JSON.stringify({ lists, selectedListId, togglApiToken, savedAt: new Date().toISOString() });
                          localStorage.setItem(LISTS_STORAGE_KEY, payload);
                          setShowTogglSettings(false);
                          alert('✓ Toggl 연결 완료');
                        }}
                        className="flex-1 px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition"
                      >
                        저장
                      </button>
                      {togglApiToken && (
                        <button
                          onClick={() => {
                            TogglIntegration.setApiToken('');
                            setTogglApiToken('');
                            const payload = JSON.stringify({ lists, selectedListId, togglApiToken: '', savedAt: new Date().toISOString() });
                            localStorage.setItem(LISTS_STORAGE_KEY, payload);
                            setShowTogglSettings(false);
                          }}
                          className="px-3 py-1.5 bg-red-500 hover:bg-red-400 text-white rounded text-sm transition"
                        >
                          연결 해제
                        </button>
                      )}
                    </div>
                  </div>
                  <button onClick={() => setShowTogglSettings(false)} className="mt-3 w-full px-3 py-1.5 bg-gray-600 hover:bg-gray-500 text-white rounded text-sm transition">닫기</button>
                </div>
              </div>
            )}

            {showShortcuts && (
              <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={() => setShowShortcuts(false)}>
                <div className="bg-gray-800 rounded-lg p-4 max-w-md w-full" onClick={(e) => e.stopPropagation()}>
                  <h2 className="text-sm font-bold text-white mb-3">⌨️ 단축키</h2>
                  <div className="space-y-2 text-xs text-gray-300">
                    <div className="flex justify-between"><span>Ctrl+Space</span><span>타이머 시작/정지</span></div>
                    <div className="flex justify-between"><span>Ctrl+Enter</span><span>완료 토글</span></div>
                    <div className="flex justify-between"><span>Alt+↑↓</span><span>카드/리스트 순서 변경</span></div>
                    <div className="flex justify-between"><span>Delete</span><span>삭제</span></div>
                  </div>
                  <button onClick={() => setShowShortcuts(false)} className="mt-3 w-full px-3 py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-sm transition">닫기</button>
                </div>
              </div>
            )}
            <div className="max-w-5xl mx-auto flex">
              {isSidebarOpen && (
                <div className="fixed inset-0 bg-black/70 sm:hidden z-20" onClick={() => setIsSidebarOpen(false)} />
              )}
              {/* Sidebar */}
              <div 
                className={`fixed sm:static inset-y-0 left-0 z-30 w-64 transform ${isSidebarOpen ? "translate-x-0" : "-translate-x-full sm:translate-x-0"} transition-transform duration-200 sm:w-60 bg-gray-900 border-r border-gray-800 px-3 py-2 overflow-visible flex flex-col`}
                onTouchStart={(e) => {
                  setTouchStartX(e.touches[0].clientX);
                  setTouchStartY(e.touches[0].clientY);
                }}
                onTouchEnd={(e) => {
                  if (!touchStartX || !touchStartY) return;
                  const touchEndX = e.changedTouches[0].clientX;
                  const touchEndY = e.changedTouches[0].clientY;
                  const deltaX = touchEndX - touchStartX;
                  const deltaY = touchEndY - touchStartY;
                  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                    if (deltaX < 0) setIsSidebarOpen(false);
                  }
                  setTouchStartX(null);
                  setTouchStartY(null);
                }}
              >
                <div className="flex items-center justify-between mb-2">
                  <h2 className="text-sm font-semibold text-gray-200">리스트</h2>
                  <div className="flex items-center gap-2">
                    <button onClick={() => setListsEditMode((v)=>!v)} className={`text-xs px-1.5 py-0.5 rounded border ${listsEditMode?"border-blue-400 text-blue-300":"border-gray-700 text-gray-400"}`}>{listsEditMode?"완료":"수정"}</button>
                    <button onClick={() => setIsSidebarOpen(false)} className="sm:hidden text-gray-400 text-xs">닫기</button>
                  </div>
                </div>
                <div className="flex gap-2 mb-2">
                  <input id="new-list-input" type="text" placeholder="새 리스트" onKeyDown={handleListKeyDown} className="flex-1 px-2 py-1 rounded bg-gray-800 border border-gray-700 text-sm text-gray-100 focus:outline-none focus:border-blue-400"/>
                </div>
                <div className="flex-1 space-y-1 p-1" style={{overflowY: 'auto', overflowX: 'visible'}}>
                  {(lists.length ? lists : [{ id: "default", name: "기본함" }]).map((l, idx) => (
                    <div
                      key={l.id}
                      draggable
                      onContextMenu={(e) => handleListContextMenu(e, l.id)}
                      onDragStart={()=>handleListDragStart(l.id)}
                      onDragOver={handleListDragOver}
                      onDragEnter={(e)=>handleListDragEnter(e,l.id)}
                      onDragLeave={handleListDragLeave}
                      onDrop={()=>handleListDrop(l.id)}
                      className={`sidebar-list-item flex items-center justify-between px-3 py-2 cursor-pointer text-sm rounded-lg ${selectedListId === l.id ? "bg-blue-600 text-white font-semibold" : "text-gray-300 hover:bg-gray-800"} ${draggingListId===l.id?"opacity-60":""} ${sidebarFocused && selectedListIndex === idx ? "ring-2 ring-blue-400" : ""}`}
                      onClick={() => setSelectedListId(l.id)}
                    >
                      <span className="truncate">{l.name}</span>
                      {listsEditMode && l.id !== "default" && (
                        <button onClick={(e) => { e.stopPropagation(); deleteList(l.id); }} className="text-gray-400 hover:text-red-400 text-xs">삭제</button>
                      )}
                    </div>
                  ))}
                </div>
                <div className="hidden sm:flex justify-start pt-2 border-t border-gray-800">
                  <button
                    onClick={(e) => { e.stopPropagation(); setShowShortcuts(true); }}
                    className="h-10 w-10 flex items-center justify-center rounded-full bg-gray-700 hover:bg-gray-600 text-white shadow-lg cursor-pointer"
                    title="단축키"
                  >
                    ⌨️
                  </button>
                </div>
              </div>

              {/* Content */}
              <div 
                className="flex-1 sm:pl-6"
                onTouchStart={(e) => {
                  if (isSidebarOpen) return;
                  setTouchStartX(e.touches[0].clientX);
                  setTouchStartY(e.touches[0].clientY);
                }}
                onTouchEnd={(e) => {
                  if (isSidebarOpen || !touchStartX || !touchStartY) return;
                  const touchEndX = e.changedTouches[0].clientX;
                  const touchEndY = e.changedTouches[0].clientY;
                  const deltaX = touchEndX - touchStartX;
                  const deltaY = touchEndY - touchStartY;
                  if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 100) {
                    if (deltaX > 0 && touchStartX < 50) setIsSidebarOpen(true);
                  }
                  setTouchStartX(null);
                  setTouchStartY(null);
                }}
              >
                {/* Global hidden file input for import on all viewports */}
                <input
                  ref={persistence.fileInputRef}
                  type="file"
                  accept="application/json,.json"
                  className="hidden"
                  onChange={persistence.handleFileSelected}
                />
                <div className="sm:hidden px-2 py-2">
                  <div className="flex items-center justify-between gap-1 mb-1.5">
                    <div className="flex items-center gap-1">
                      <button onClick={() => setIsSidebarOpen(true)} className="px-2 py-1 rounded border border-gray-700 text-gray-200 text-sm flex-shrink-0">☰</button>
                      <div className="px-1.5 py-0.5 bg-gray-800 rounded text-[10px] text-cyan-400 whitespace-nowrap flex-shrink-0">
                        {Math.floor(getTodayTotalSeconds() / 3600)}h {Math.floor((getTodayTotalSeconds() % 3600) / 60)}m
                      </div>
                    </div>
                    <div className="flex items-center gap-1 flex-shrink-0">
                      <div className="flex items-center gap-1">
                        {dropboxConnected && lastDropboxSync && <span className="text-xs text-gray-400">{formatRelativeTime(lastDropboxSync)}</span>}
                        <div className="relative">
                          <button
                            onClick={(e) => { e.stopPropagation(); setShowDropboxMenu(!showDropboxMenu); }}
                            className={`h-7 w-7 flex items-center justify-center rounded-full ${dropboxConnected ? 'bg-gradient-to-br from-blue-500 to-cyan-500' : 'bg-gray-700'} text-white relative shadow-lg transition-all hover:scale-105`}
                            title={dropboxConnected ? `클라우드 연결됨${lastDropboxSync ? ` - ${formatRelativeTime(lastDropboxSync)}` : ''}` : '클라우드 연결 안됨'}
                          >
                            📦
                            {dropboxSyncing && <span className="absolute -top-0.5 -right-0.5 w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>}
                          </button>
                          {showDropboxMenu && (
                            <div className="absolute right-0 mt-1 bg-gray-900 border border-gray-700 rounded-md shadow-xl py-0.5 z-50 min-w-[100px]" onClick={(e) => e.stopPropagation()}>
                              {!dropboxConnected ? (
                                <button onClick={connectDropbox} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800">연결</button>
                              ) : (
                                <>
                                  <button onClick={syncToDropbox} disabled={dropboxSyncing} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800 disabled:opacity-50">{dropboxSyncing ? '⏳' : '↑'}</button>
                                  <button onClick={syncFromDropbox} disabled={dropboxSyncing} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800 disabled:opacity-50">{dropboxSyncing ? '⏳' : '↓'}</button>
                                  <button onClick={disconnectDropbox} className="w-full px-2 py-1 text-left text-[11px] text-red-400 hover:bg-gray-800">해제</button>
                                </>
                              )}
                            </div>
                          )}
                        </div>
                      </div>
                      <button
                        onClick={() => setShowTimeline(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-indigo-500 to-purple-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="타임라인"
                      >
                        📅
                      </button>
                      <button
                        onClick={() => setShowWeeklyReport(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-purple-500 to-pink-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="주간 리포트"
                      >
                        📊
                      </button>
                      <button
                        onClick={() => setShowStats(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-yellow-500 to-orange-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="통계 & 배지"
                      >
                        🏆
                      </button>
                      <a
                        href="todos.html"
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-green-500 to-teal-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="할일 페이지"
                      >
                        ✓
                      </a>
                      <button
                        onClick={() => setShowTogglSettings(true)}
                        className={`h-7 w-7 flex items-center justify-center rounded-full ${togglApiToken ? 'bg-gradient-to-br from-pink-500 to-red-500' : 'bg-gray-700 hover:bg-gray-600'} text-white transition-all hover:scale-105 shadow-lg relative`}
                        title={togglApiToken ? 'Toggl 연결됨' : 'Toggl 설정'}
                      >
                        ⏱️
                        {togglRunning && <span className="absolute -top-0.5 -right-0.5 w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>}
                      </button>
                      {!dropboxConnected && (
                        <>
                          <button
                            onClick={persistence.triggerImport}
                            className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-cyan-500 to-blue-500 text-white shadow-lg transition-all hover:scale-105"
                            title="가져오기"
                          >
                            <Download size={12} />
                          </button>
                          <div className="flex items-center gap-1">
                            {persistence.fileHandleRef?.current ? (
                              persistence.lastSavedAt && <span className="text-xs text-gray-400">{formatRelativeTime(persistence.lastSavedAt)}</span>
                            ) : (
                              <span className="text-xs text-gray-400">파일 연결 안됨</span>
                            )}
                            <button
                              onClick={persistence.triggerSync}
                              className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-blue-500 to-indigo-500 text-white shadow-lg transition-all hover:scale-105"
                              title="동기화"
                              disabled={persistence.isSyncing}
                            >
                              <RefreshCcw size={12} className={persistence.isSyncing ? "animate-spin" : ""} />
                            </button>
                          </div>
                        </>
                      )}
                    </div>
                  </div>
                </div>
                <div className="max-w-3xl mx-auto">
              <div className="mb-6">
                  <div className="hidden sm:flex items-center justify-between gap-2">
                    <div className="px-1.5 py-0.5 bg-gray-800 rounded text-[10px] text-cyan-400 whitespace-nowrap">
                      {Math.floor(getTodayTotalSeconds() / 3600)}h {Math.floor((getTodayTotalSeconds() % 3600) / 60)}m
                    </div>
                    <div className="flex items-center gap-2">
                      <div className="flex items-center gap-1">
                        {dropboxConnected && lastDropboxSync && <span className="text-xs text-gray-400">{formatRelativeTime(lastDropboxSync)}</span>}
                        <div className="relative">
                          <button
                            onClick={(e) => { e.stopPropagation(); setShowDropboxMenu(!showDropboxMenu); }}
                            className={`h-7 w-7 flex items-center justify-center rounded-full ${dropboxConnected ? 'bg-gradient-to-br from-blue-500 to-cyan-500' : 'bg-gray-700 hover:bg-gray-600'} text-white transition-all hover:scale-105 relative shadow-lg`}
                            title={dropboxConnected ? `클라우드 연결됨${lastDropboxSync ? ` - ${formatRelativeTime(lastDropboxSync)}` : ''}` : '클라우드 연결 안됨'}
                          >
                            📦
                            {dropboxSyncing && <span className="absolute -top-0.5 -right-0.5 w-2 h-2 bg-green-400 rounded-full animate-pulse"></span>}
                          </button>
                          {showDropboxMenu && (
                            <div className="absolute right-0 mt-1 bg-gray-900 border border-gray-700 rounded-md shadow-xl py-0.5 z-50 min-w-[100px]" onClick={(e) => e.stopPropagation()}>
                              {!dropboxConnected ? (
                                <button onClick={connectDropbox} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800">연결</button>
                              ) : (
                                <>
                                  <button onClick={syncToDropbox} disabled={dropboxSyncing} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800 disabled:opacity-50">{dropboxSyncing ? '⏳' : '↑'}</button>
                                  <button onClick={syncFromDropbox} disabled={dropboxSyncing} className="w-full px-2 py-1 text-left text-[11px] text-gray-200 hover:bg-gray-800 disabled:opacity-50">{dropboxSyncing ? '⏳' : '↓'}</button>
                                  <button onClick={disconnectDropbox} className="w-full px-2 py-1 text-left text-[11px] text-red-400 hover:bg-gray-800">해제</button>
                                </>
                              )}
                            </div>
                          )}
                        </div>
                      </div>
                      <button
                        onClick={() => setShowTimeline(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-indigo-500 to-purple-500 text-white transition-all hover:scale-105 text-xs shadow-lg"
                        title="타임라인"
                      >
                        📅
                      </button>
                      <button
                        onClick={() => setShowWeeklyReport(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-purple-500 to-pink-500 text-white transition-all hover:scale-105 text-xs shadow-lg"
                        title="주간 리포트"
                      >
                        📊
                      </button>
                      <button
                        onClick={() => setShowStats(true)}
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-yellow-500 to-orange-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="통계 & 배지"
                      >
                        🏆
                      </button>
                      <a
                        href="todos.html"
                        className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-green-500 to-teal-500 text-white text-xs shadow-lg transition-all hover:scale-105"
                        title="할일 페이지"
                      >
                        ✓
                      </a>
                      <button
                        onClick={() => setShowTogglSettings(true)}
                        className={`h-7 w-7 flex items-center justify-center rounded-full ${togglApiToken ? 'bg-gradient-to-br from-pink-500 to-red-500' : 'bg-gray-700 hover:bg-gray-600'} text-white transition-all hover:scale-105 shadow-lg`}
                        title={togglApiToken ? 'Toggl 연결됨' : 'Toggl 설정'}
                      >
                        ⏱️
                      </button>
                    {!dropboxConnected && (
                      <>
                        <button
                          onClick={persistence.triggerImport}
                          className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-cyan-500 to-blue-500 text-white transition-all hover:scale-105 shadow-lg"
                          title="가져오기"
                        >
                          <Download size={12} />
                        </button>
                        <div className="flex items-center gap-1">
                          {persistence.fileHandleRef?.current ? (
                            persistence.lastSavedAt && <span className="text-xs text-gray-400">{formatRelativeTime(persistence.lastSavedAt)}</span>
                          ) : (
                            <span className="text-xs text-gray-400">파일 연결 안됨</span>
                          )}
                          <button
                            onClick={persistence.triggerSync}
                            className="h-7 w-7 flex items-center justify-center rounded-full bg-gradient-to-br from-blue-500 to-indigo-500 text-white transition-all hover:scale-105 shadow-lg"
                            title="동기화"
                            disabled={persistence.isSyncing}
                          >
                            <RefreshCcw size={12} className={persistence.isSyncing ? "animate-spin" : ""} />
                          </button>
                        </div>
                      </>
                    )}
                    </div>
                  </div>
              </div>

              <div className="card-blur rounded-lg p-2 sm:p-2.5 mb-3 mx-2 sm:mx-0">
                <div className="flex flex-wrap gap-1.5">
                  <input
                    type="text"
                    placeholder="목표 이름"
                    value={newGoalName}
                    onChange={(e) => setNewGoalName(e.target.value)}
                    onKeyPress={handleKeyPress}
                    className="flex-1 w-full sm:w-auto px-2 py-1 sm:py-1.5 bg-gray-800 text-gray-100 rounded border border-gray-700 focus:outline-none focus:border-blue-400 text-sm"
                  />
                  <input
                    type="number"
                    placeholder="시간"
                    value={newGoalTargetHours}
                    onChange={(e) => setNewGoalTargetHours(e.target.value)}
                    onKeyPress={handleKeyPress}
                    className="w-14 px-2 py-1 sm:py-1.5 bg-gray-800 text-gray-100 rounded border border-gray-700 focus:outline-none focus:border-blue-400 text-sm"
                  />
                  <input
                    type="number"
                    placeholder="분"
                    value={newGoalTargetMinutes}
                    onChange={(e) => setNewGoalTargetMinutes(e.target.value)}
                    onKeyPress={handleKeyPress}
                    className="w-14 px-2 py-1 sm:py-1.5 bg-gray-800 text-gray-100 rounded border border-gray-700 focus:outline-none focus:border-blue-400 text-sm"
                  />
                  <button
                    onClick={addGoal}
                    className="px-2 py-1 sm:py-1.5 bg-blue-500 hover:bg-blue-400 text-white rounded font-semibold flex items-center gap-1 text-xs sm:text-sm"
                  >
                    <Plus size={12} /> 추가
                  </button>
                </div>
              </div>

              {todayPendingGoals.length > 0 && showDailySuggestion && (
                <div className="card-blur rounded-lg p-3 mb-3 border-l-4 border-blue-500 mx-2 sm:mx-0">
                  <div className="flex items-start justify-between gap-2">
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="text-sm font-semibold text-blue-400">💡 오늘의 목표</span>
                        <span className="text-xs text-gray-400">{todayPendingGoals.length}개 대기중</span>
                      </div>
                      <p className="text-xs text-gray-300 mb-2">아직 작업하지 않은 목표가 있어요. 지금 시작해보세요!</p>
                      <div className="flex flex-wrap gap-1">
                        {todayPendingGoals.slice(0, 3).map(g => {
                          const suggestion = getDailySuggestion(g);
                          return (
                            <button
                              key={g.id}
                              onClick={() => startTimer(g.id)}
                              className="text-xs px-2 py-1 bg-blue-500/20 hover:bg-blue-500/30 text-blue-300 rounded border border-blue-500/30 transition"
                            >
                              {g.name} {suggestion && `(오늘 ${suggestion})`}
                            </button>
                          );
                        })}
                      </div>
                    </div>
                    <button
                      onClick={() => setShowDailySuggestion(false)}
                      className="text-gray-500 hover:text-gray-300 text-xs"
                    >
                      ✕
                    </button>
                  </div>
                </div>
              )}

              <div className="space-y-4 px-2 sm:px-0">
                {filteredGoals.length === 0 ? (
                  <div className="text-center py-8 text-gray-400 text-sm">목표를 추가해보세요</div>
                ) : (
                  <>
                  {draggingGoalId && (
                    <div
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => {
                        if (draggingGoalId) {
                          setGoals((prevGoals) => {
                            const fromIdx = prevGoals.findIndex((g) => g.id === draggingGoalId);
                            if (fromIdx === -1) return prevGoals;
                            const next = prevGoals.slice();
                            const [moved] = next.splice(fromIdx, 1);
                            next.unshift(moved);
                            return next;
                          });
                          setDraggingGoalId(null);
                          setDragOverGoalId(null);
                        }
                      }}
                      className="h-8"
                    />
                  )}
                  {sortedGoals.map((goal) => {
                    const isActive = activeTimer === goal.id;
                    const extraSeconds = isActive ? timerSeconds : 0;
                    const effectiveSeconds = goal.totalSeconds + extraSeconds;
                    const progress = getProgress(goal, effectiveSeconds);
                    const hours = effectiveSeconds / 3600;
                    const isComplete = goal.completedAt;
                    const streak = getStreak(goal);
                    const workedToday = hasWorkedToday(goal);
                    const dailySuggestion = getDailySuggestion(goal);

                    return (
                      <div key={`wrap-${goal.id}`}>
                        {dragOverGoalId === goal.id && draggingGoalId !== goal.id && dragPosition === 'before' && (
                          <div className="h-0.5 bg-blue-400 mb-2" />
                        )}
                      <div
                        ref={(el) => cardRefs.current[sortedGoals.indexOf(goal)] = el}
                        draggable
                        onContextMenu={(e) => handleContextMenu(e, goal.id)}
                        onClick={() => setSelectedCardIndex(sortedGoals.indexOf(goal))}
                        onMouseDown={(e) => {
                          if (e.target.isContentEditable || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                            e.currentTarget.draggable = false;
                          } else {
                            e.currentTarget.draggable = true;
                          }
                        }}
                        onDragStart={(e) => {
                          if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                            e.preventDefault();
                            return;
                          }
                          handleDragStart(goal.id);
                        }}
                        onDragEnd={() => {
                          setDraggingGoalId(null);
                          setDragOverGoalId(null);
                        }}
                        onDragOver={(e) => e.preventDefault()}
                        onDragEnter={(e) => handleDragEnter(e, goal.id)}
                        onDragLeave={handleDragLeave}
                        onDrop={() => handleDrop(goal.id)}
                        className={`p-2.5 transition-transform duration-200 hover:-translate-y-0.5 ${
                          isComplete
                            ? "card-complete rounded-lg"
                            : "card-blur rounded-lg"
                        } ${draggingGoalId === goal.id ? "opacity-60" : ""} ${!sidebarFocused && sortedGoals.indexOf(goal) === selectedCardIndex ? "ring-2 ring-blue-400" : ""}`}
                        style={{ borderLeft: `4px solid ${goalColors.current[goal.id] || '#3b82f6'}` }}
                      >
                        <div className="flex justify-between items-start mb-2 gap-1.5">
                          <div className="flex items-start gap-2 flex-1 min-w-0">
                            <button
                              onClick={() => toggleComplete(goal.id)}
                              className={`text-sm px-2 py-1 rounded border transition flex-shrink-0 ${
                                goal.completedAt
                                  ? "border-emerald-400 text-emerald-300 hover:border-emerald-300"
                                  : "border-gray-600 text-gray-400 hover:border-gray-500"
                              }`}
                              title={goal.completedAt ? "완료 취소" : "완료"}
                            >
                              ✓
                            </button>
                            <div className="flex-1 min-w-0">
                            <div className="space-y-1.5 min-w-0">
                              <div className="flex items-center gap-2 min-w-0">
                                <div
                                  data-goal-name={goal.id}
                                  contentEditable
                                  suppressContentEditableWarning
                                  onBlur={(e) => updateGoalName(goal.id, e.currentTarget.textContent)}
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                      e.preventDefault();
                                      e.currentTarget.blur();
                                    }
                                  }}
                                  className={`text-white text-sm font-semibold px-2 py-0.5 cursor-pointer hover:bg-gray-800/50 rounded transition focus:outline-none focus:bg-gray-800 focus:border focus:border-blue-400 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 0 ? "ring-2 ring-yellow-400" : ""}`}
                                >
                                  {goal.name || ""}
                                </div>
                                {streak > 1 && (
                                  <span className="text-xs text-orange-400 flex items-center gap-0.5 flex-shrink-0" title={`${streak}일 연속`}>
                                    🔥{streak}
                                  </span>
                                )}
                                <span className="text-gray-400 text-sm whitespace-nowrap flex-shrink-0">{progress.toFixed(0)}%</span>
                                {getAchievementBadge(goal) && (
                                  <span className="text-sm flex-shrink-0">{getAchievementBadge(goal)}</span>
                                )}
                              </div>
                              <div className="flex items-center text-xs text-gray-400 flex-wrap">
                                {!workedToday && !isComplete && (
                                  <span className="text-blue-400 whitespace-nowrap mr-1">⏰ 오늘</span>
                                )}
                                {dailySuggestion && !isComplete && (
                                  <span className="text-green-400 whitespace-nowrap mr-1">{dailySuggestion}/d</span>
                                )}
                                <span className="whitespace-nowrap">기록 {formatHoursVerbose(hours)} / 목표 <span
                                  data-goal-hours={goal.id}
                                  contentEditable
                                  suppressContentEditableWarning
                                  onBlur={(e) => {
                                    const hours = parseFloat(e.currentTarget.textContent) || 0;
                                    const minutes = Math.round(((goal.targetHours ?? 0) % 1) * 60);
                                    updateGoalTarget(goal.id, (hours + minutes / 60).toString());
                                  }}
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                      e.preventDefault();
                                      e.currentTarget.blur();
                                    }
                                  }}
                                  className={`text-gray-100 cursor-pointer hover:bg-gray-800/50 rounded transition focus:outline-none focus:bg-gray-800 focus:border focus:border-blue-400 px-0.5 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 1 ? "ring-2 ring-yellow-400" : ""}`}
                                >{Math.floor(goal.targetHours ?? 0)}</span>시간 <span
                                  data-goal-minutes={goal.id}
                                  contentEditable
                                  suppressContentEditableWarning
                                  onBlur={(e) => {
                                    const hours = Math.floor(goal.targetHours ?? 0);
                                    const minutes = parseFloat(e.currentTarget.textContent) || 0;
                                    updateGoalTarget(goal.id, (hours + minutes / 60).toString());
                                  }}
                                  onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                      e.preventDefault();
                                      e.currentTarget.blur();
                                    }
                                  }}
                                  className={`text-gray-100 cursor-pointer hover:bg-gray-800/50 rounded transition focus:outline-none focus:bg-gray-800 focus:border focus:border-blue-400 px-0.5 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 2 ? "ring-2 ring-yellow-400" : ""}`}
                                >{Math.round(((goal.targetHours ?? 0) % 1) * 60)}</span>분</span>
                                {(goal.completedAt || isComplete) && (
                                  <span className="text-emerald-300 whitespace-nowrap ml-1">
                                    {goal.completedAt
                                      ? `✓ ${new Date(goal.completedAt).toLocaleDateString("ko-KR", {year: '2-digit', month: 'numeric', day: 'numeric'}).replace(/\. /g, '.')}`
                                      : "✓ 완료"}
                                  </span>
                                )}
                              </div>
                            </div>
                            </div>
                          </div>
                          <button
                            onClick={() => deleteGoal(goal.id)}
                            className={`text-gray-500 hover:text-red-400 transition p-1 flex-shrink-0 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 3 ? "ring-2 ring-yellow-400 rounded" : ""}`}
                            title="삭제"
                          >
                            <Trash2 size={16} />
                          </button>
                        </div>

                        <div className="mb-2">
                          <div className="flex items-center gap-2 mb-1">
                            <div className="flex-1 h-2 bg-gray-800 rounded-full overflow-hidden">
                              <div
                                className={`h-full transition-all duration-300 ${
                                  isComplete ? "bg-blue-500" : "bg-blue-500"
                                }`}
                                style={{ width: `${progress}%` }}
                              />
                            </div>
                            <div className="text-xs font-mono min-w-[60px] text-center">
                              {isActive ? (
                                <div>
                                  <div className="text-cyan-300">{formatTime(timerSeconds)}</div>
                                  {goal.targetHours && (
                                    <div className="text-[10px] text-gray-500">
                                      {(() => {
                                        const remainingSeconds = Math.max(0, goal.targetHours * 3600 - effectiveSeconds);
                                        return formatTime(remainingSeconds);
                                      })()}
                                    </div>
                                  )}

                                </div>
                              ) : (
                                goal.targetHours ? (
                                  <span className="text-gray-500">{formatTime(Math.max(0, goal.targetHours * 3600 - goal.totalSeconds))}</span>
                                ) : (
                                  <span className="text-cyan-300">00:00:00</span>
                                )
                              )}
                            </div>
                            <div className="flex items-center gap-1">
                              {isActive && (
                                <button
                                  onClick={() => cancelTimer(goal.id)}
                                  className="px-1.5 py-0.5 rounded-md font-semibold flex items-center gap-0.5 text-xs bg-red-500/90 hover:bg-red-400 text-white transition"
                                >
                                  <X size={12} />
                                </button>
                              )}
                              <button
                                onClick={() => (isActive ? stopTimer(goal.id) : startTimer(goal.id))}
                                className={`px-1.5 py-0.5 rounded-md font-semibold flex items-center gap-0.5 transition text-xs ${
                                  isActive
                                    ? "bg-rose-500 hover:bg-rose-400 text-white"
                                    : !workedToday && !isComplete
                                    ? "bg-green-500 hover:bg-green-400 text-white pulse-start"
                                    : "bg-green-500 hover:bg-green-400 text-white"
                                } ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 4 ? "ring-2 ring-yellow-400" : ""}`}
                              >
                                {isActive ? <Pause size={14} /> : <Play size={14} />}
                              </button>
                            </div>
                          </div>
                          {isActive && (
                            <input
                              type="text"
                              placeholder="메모 추가"
                              value={timerMemo}
                              onChange={(e) => setTimerMemo(e.target.value)}
                              className="w-full px-2 py-0.5 rounded border border-gray-700 bg-gray-800 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                            />
                          )}
                        </div>
                        <div>
                          {goal.todos && goal.todos.length > 0 ? (
                            <>
                            <div className="text-xs text-gray-400 mb-1">할일 ({goal.todos.filter(t => !t.done).length}/{goal.todos.length})</div>
                            <div>
                              {(expandedTodos.has(goal.id) ? goal.todos : goal.todos.slice(0, todoShowCounts.get(goal.id) || 5)).map((todo) => {
                                const isEditing = editingTodoId === todo.id;
                                const isSelected = selectedTodoId === todo.id;
                                const isTodoTimerActive = activeTimer === goal.id && timerMemo === todo.text;
                                return (
                                  <div
                                    key={todo.id}
                                    className="flex items-center gap-2 text-xs cursor-pointer hover:bg-gray-800/30 rounded px-1 py-0.5 -mx-1 min-h-[24px]"
                                    onClick={(e) => {
                                      if (!isEditing && e.target.tagName !== 'INPUT' && e.target.tagName !== 'BUTTON') {
                                        setSelectedTodoId(todo.id);
                                        setEditingTodoId(todo.id);
                                      }
                                    }}
                                    onContextMenu={(e) => {
                                      e.preventDefault();
                                      e.stopPropagation();
                                      setTodoContextMenu({ x: e.clientX, y: e.clientY, goalId: goal.id, todoId: todo.id });
                                    }}
                                  >
                                    <input
                                      type="checkbox"
                                      checked={todo.done}
                                      onChange={() => {
                                        if (!todo.done) {
                                          const actualSeconds = isTodoTimerActive ? timerSeconds : (todo.estimatedMinutes || 0) * 60;
                                          setGoals((prev) => prev.map((g) => {
                                            if (g.id === goal.id) {
                                              return {
                                                ...g,
                                                todos: g.todos.filter(t => t.id !== todo.id),
                                                logs: [{ date: new Date().toLocaleDateString("ko-KR"), seconds: actualSeconds, memo: todo.text, fromTodo: true, estimated: todo.estimatedMinutes }, ...g.logs]
                                              };
                                            }
                                            return g;
                                          }));
                                        } else {
                                          setGoals((prev) => prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, done: !t.done } : t) } : g));
                                        }
                                      }}
                                      className="w-3 h-3"
                                    />
                                    {isEditing ? (
                                      <div className="flex-1 flex items-center gap-1">
                                        <input
                                          type="number"
                                          defaultValue={todo.estimatedMinutes || ''}
                                          placeholder="분"
                                          onBlur={(e) => {
                                            const val = parseInt(e.target.value) || 0;
                                            setGoals((prev) => prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, estimatedMinutes: val } : t) } : g));
                                          }}
                                          className="w-12 px-1 bg-gray-700 text-gray-100 rounded border border-blue-400 focus:outline-none text-xs h-[24px]"
                                        />
                                        <input
                                          type="text"
                                          defaultValue={todo.text}
                                          autoFocus
                                          onBlur={(e) => {
                                            setGoals((prev) => prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, text: e.target.value.trim() || todo.text } : t) } : g));
                                            setEditingTodoId(null);
                                            setSelectedTodoId(null);
                                          }}
                                          onKeyDown={(e) => {
                                            if (e.key === 'Tab') {
                                              e.preventDefault();
                                              const currentIndent = todo.indent || 0;
                                              const newIndent = e.shiftKey ? Math.max(0, currentIndent - 1) : Math.min(3, currentIndent + 1);
                                              setGoals((prev) => {
                                                const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, indent: newIndent } : t) } : g);
                                                saveHistory(newGoals);
                                                return newGoals;
                                              });
                                            } else if (e.key === 'Enter') {
                                              e.preventDefault();
                                              const newText = e.target.value.trim();
                                              if (newText) {
                                                setGoals((prev) => {
                                                  const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, text: newText } : t) } : g);
                                                  saveHistory(newGoals);
                                                  return newGoals;
                                                });
                                              }
                                              setEditingTodoId(null);
                                              setSelectedTodoId(null);
                                              setShowAddTodo(goal.id);
                                              setTimeout(() => {
                                                const input = document.querySelector('input[placeholder="할일 입력"]');
                                                if (input) input.focus();
                                              }, 0);
                                            } else if (e.key === 'Escape') { 
                                              setEditingTodoId(null); 
                                            }
                                          }}
                                          className="flex-1 px-1 bg-gray-700 text-gray-100 rounded border border-blue-400 focus:outline-none text-xs h-[24px]"
                                          style={{ marginLeft: `${(todo.indent || 0) * 8}px` }}
                                        />
                                        <button
                                          onMouseDown={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            const currentIndent = todo.indent || 0;
                                            if (currentIndent > 0) {
                                              setGoals((prev) => {
                                                const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, indent: currentIndent - 1 } : t) } : g);
                                                saveHistory(newGoals);
                                                return newGoals;
                                              });
                                            }
                                          }}
                                          className="px-1.5 h-[24px] bg-gray-600 text-white rounded text-xs flex-shrink-0 flex items-center justify-center"
                                        >
                                          {'<'}
                                        </button>
                                        <button
                                          onMouseDown={(e) => {
                                            e.preventDefault();
                                            e.stopPropagation();
                                            const currentIndent = todo.indent || 0;
                                            if (currentIndent < 3) {
                                              setGoals((prev) => {
                                                const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.map((t) => t.id === todo.id ? { ...t, indent: currentIndent + 1 } : t) } : g);
                                                saveHistory(newGoals);
                                                return newGoals;
                                              });
                                            }
                                          }}
                                          className="px-1.5 h-[24px] bg-gray-600 text-white rounded text-xs flex-shrink-0 flex items-center justify-center"
                                        >
                                          {'>'}
                                        </button>
                                      </div>
                                    ) : (
                                      <span
                                        onClick={() => { setSelectedTodoId(todo.id); setEditingTodoId(todo.id); }}
                                        className={`flex-1 cursor-pointer hover:text-gray-100 leading-[24px] ${todo.done ? 'line-through text-gray-500' : 'text-gray-300'}`}
                                        style={{ marginLeft: `${(todo.indent || 0) * 8}px` }}
                                      >
                                        {todo.estimatedMinutes && <span className="text-blue-400 text-[10px] mr-1">{todo.estimatedMinutes}분</span>}
                                        {todo.text}
                                      </span>
                                    )}
                                    <div className="flex items-center gap-1">
                                      {isTodoTimerActive && (
                                        <button
                                          onClick={(e) => { e.stopPropagation(); cancelTimer(goal.id); }}
                                          className="px-1.5 py-0.5 rounded-md font-semibold flex items-center gap-0.5 text-xs bg-red-500/90 hover:bg-red-400 text-white transition"
                                        >
                                          <X size={12} />
                                        </button>
                                      )}
                                      {isEditing && (
                                        <button
                                          onMouseDown={(e) => { e.preventDefault(); e.stopPropagation(); if (window.confirm('이 할일을 삭제할까요?')) { setGoals((prev) => prev.map((g) => g.id === goal.id ? { ...g, todos: g.todos.filter((t) => t.id !== todo.id) } : g)); setSelectedTodoId(null); setEditingTodoId(null); } }}
                                          className="text-red-400 hover:text-red-300 px-1"
                                        >
                                          ×
                                        </button>
                                      )}
                                      <button
                                        onClick={(e) => { e.stopPropagation(); (isTodoTimerActive ? stopTimer(goal.id) : startTimer(goal.id, todo.text)); }}
                                        className={`px-1.5 py-0.5 rounded-md font-semibold flex items-center gap-0.5 transition text-xs ${
                                          isTodoTimerActive
                                            ? "bg-rose-500 hover:bg-rose-400 text-white"
                                            : "bg-green-500 hover:bg-green-400 text-white"
                                        }`}
                                      >
                                        {isTodoTimerActive ? <Pause size={14} /> : <Play size={14} />}
                                      </button>
                                    </div>
                                  </div>
                                );
                              })}
                            </div>
                            </>
                          ) : (
                            <div className="text-xs text-gray-400 mb-1">할일 (0)</div>
                          )}
                        </div>
                        <div className="mb-2">
                          <div className="flex gap-1">
                            <input
                              type="text"
                              value={newTodoText}
                              onFocus={() => setShowAddTodo(goal.id)}
                              onBlur={() => {
                                if (!newTodoText.trim()) {
                                  setShowAddTodo(null);
                                }
                              }}
                              onChange={(e) => setNewTodoText(e.target.value)}
                              onKeyDown={(e) => {
                                if (e.key === 'Enter') {
                                  e.preventDefault();
                                  if (newTodoText.trim()) {
                                    setGoals((prev) => {
                                      const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: [...(g.todos || []), { id: Date.now(), text: newTodoText.trim(), done: false, indent: 0 }] } : g);
                                      saveHistory(newGoals);
                                      return newGoals;
                                    });
                                    setNewTodoText("");
                                    setShowAddTodo(null);
                                  }
                                }
                                if (e.key === 'Escape') {
                                  setNewTodoText("");
                                  setShowAddTodo(null);
                                  e.target.blur();
                                }
                              }}
                              placeholder="+ 할일 추가"
                              className="flex-1 px-2 py-0.5 bg-transparent text-gray-400 rounded border border-transparent hover:border-gray-700 focus:outline-none focus:border-blue-400 focus:bg-gray-800 focus:text-gray-100 text-xs cursor-pointer"
                            />
                            {showAddTodo === goal.id && (
                              <>
                                <button
                                  onClick={() => {
                                    if (newTodoText.trim()) {
                                      setGoals((prev) => {
                                        const newGoals = prev.map((g) => g.id === goal.id ? { ...g, todos: [...(g.todos || []), { id: Date.now(), text: newTodoText.trim(), done: false, indent: 0 }] } : g);
                                        saveHistory(newGoals);
                                        return newGoals;
                                      });
                                      setNewTodoText("");
                                    }
                                    setShowAddTodo(null);
                                  }}
                                  className="px-1.5 py-0.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-xs"
                                >
                                  추가
                                </button>
                                <button
                                  onClick={() => {
                                    setNewTodoText("");
                                    setShowAddTodo(null);
                                  }}
                                  className="px-1.5 py-0.5 bg-gray-600 hover:bg-gray-500 text-white rounded text-xs"
                                >
                                  취소
                                </button>
                              </>
                            )}
                          </div>
                        </div>
                        {goal.todos && goal.todos.length > (todoShowCounts.get(goal.id) || 5) && (
                          <div className="flex items-center justify-center gap-2">
                            <button
                              onClick={(e) => { e.stopPropagation(); toggleExpandedTodos(goal.id); }}
                              className="text-xs text-gray-400 hover:text-gray-200"
                            >
                              {expandedTodos.has(goal.id) ? "접기" : "더보기"}
                            </button>
                            {editingTodoCount === goal.id ? (
                              <input
                                type="number"
                                min="1"
                                defaultValue={todoShowCounts.get(goal.id) || 5}
                                autoFocus
                                onBlur={(e) => {
                                  const val = Math.max(1, parseInt(e.target.value) || 5);
                                  setTodoShowCounts(prev => new Map(prev).set(goal.id, val));
                                  setEditingTodoCount(null);
                                }}
                                onKeyDown={(e) => {
                                  if (e.key === 'Enter') e.target.blur();
                                  if (e.key === 'Escape') { setEditingTodoCount(null); }
                                }}
                                className="w-12 px-1 py-0.5 bg-gray-700 text-gray-100 rounded text-xs"
                              />
                            ) : (
                              <span
                                onClick={() => setEditingTodoCount(goal.id)}
                                className="text-xs text-gray-500 hover:text-gray-300 cursor-pointer"
                              >
                                ({todoShowCounts.get(goal.id) || 5})
                              </span>
                            )}
                          </div>
                        )}
                        {goal.logs.length > 0 && (
                          <div className="mt-3">
                            <div className="flex items-center justify-between mb-1">
                              <span className="text-xs text-gray-400">기록 ({goal.logs.length})</span>
                              <button
                                onClick={() => setShowAddLog(showAddLog === goal.id ? null : goal.id)}
                                className={`text-xs text-gray-400 hover:text-gray-200 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 5 ? "ring-2 ring-yellow-400 rounded px-1" : ""}`}
                              >
                                + 추가
                              </button>
                            </div>
                            <div className="grid grid-cols-1 sm:grid-cols-2 gap-1">
                              {((expandedLogsGoals.has(goal.id) || editingLogsGoals.has(goal.id)) ? goal.logs : goal.logs.slice(0, logShowCounts.get(goal.id) || 6)).map((log, idx) => {
                                const originalIndex = goal.logs.indexOf(log);
                                const isEditing = editingLogIndex === `${goal.id}-${originalIndex}`;
                                const fieldOffset = 6 + originalIndex;
                                return (
                                  <div
                                    key={idx}
                                    className={`bg-gray-800/50 rounded px-1.5 py-0.5 text-xs text-gray-300 cursor-pointer hover:bg-gray-800 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === fieldOffset ? "ring-2 ring-yellow-400" : ""}`}
                                    onClick={(e) => {
                                      e.stopPropagation();
                                      if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                                      if (!isEditing) {
                                        setEditingLogIndex(`${goal.id}-${originalIndex}`);
                                        setEditLogMemo(log.memo || "");
                                        setEditLogStartTime(log.startTime || "");
                                        setEditLogEndTime(log.endTime || "");
                                      }
                                    }}
                                    onContextMenu={(e) => {
                                      e.preventDefault();
                                      e.stopPropagation();
                                      setLogContextMenu({ x: e.clientX, y: e.clientY, goalId: goal.id, logIndex: originalIndex });
                                    }}
                                  >
                                    <div className="flex items-center justify-between">
                                      <div className="flex items-center gap-1 flex-wrap">
                                        <span className="text-gray-400 whitespace-nowrap">{log.date.split('.')[1]?.trim()}/{log.date.split('.')[2]?.trim()}</span>
                                        {log.startTime && log.endTime && (
                                          <span className="text-gray-500 text-[10px] whitespace-nowrap">{log.startTime}-{log.endTime}</span>
                                        )}
                                        {log.fromTodo ? (
                                          <>
                                            <span className={`px-1 py-0.5 rounded text-[10px] whitespace-nowrap ${log.seconds > 0 ? 'bg-purple-500/30 text-purple-300' : 'bg-green-500/30 text-green-300'}`}>
                                              {log.seconds > 0 ? '할일' : '할일 완료'}
                                            </span>
                                            {log.seconds > 0 && <span className="text-cyan-400 whitespace-nowrap">+{formatHoursVerbose(log.seconds / 3600)}</span>}
                                          </>
                                        ) : (
                                          <span className="text-cyan-400 whitespace-nowrap">+{formatHoursVerbose(log.seconds / 3600)}</span>
                                        )}
                                      </div>
                                      <div className="flex items-center gap-1">
                                        {isEditing && log.fromTodo && (
                                          <button
                                            onMouseDown={(e) => {
                                              e.stopPropagation();
                                              e.preventDefault();
                                              if (window.confirm('이 기록을 할일로 되돌릴까요?')) {
                                                setGoals((prev) => prev.map((g) => {
                                                  if (g.id === goal.id) {
                                                    return {
                                                      ...g,
                                                      todos: [...(g.todos || []), { id: Date.now(), text: log.memo, done: false }],
                                                      logs: g.logs.filter((_, i) => i !== originalIndex)
                                                    };
                                                  }
                                                  return g;
                                                }));
                                                setEditingLogIndex(null);
                                              }
                                            }}
                                            className="text-purple-400 hover:text-purple-300"
                                          >
                                            <Undo2 size={12} />
                                          </button>
                                        )}
                                        {isEditing && (
                                          <button
                                            onMouseDown={(e) => {
                                              e.stopPropagation();
                                              e.preventDefault();
                                              if (window.confirm('이 기록을 삭제할까요?')) {
                                                deleteGoalLog(goal.id, originalIndex);
                                                setEditingLogIndex(null);
                                              }
                                            }}
                                            className="text-red-400 hover:text-red-300"
                                          >
                                            ×
                                          </button>
                                        )}
                                      </div>
                                    </div>
                                    {isEditing ? (
                                      <div className="mt-0.5 space-y-1">
                                        <div className="flex gap-1 items-center">
                                          <input
                                            key={`start-${goal.id}-${originalIndex}`}
                                            type="time"
                                            defaultValue={log.startTime || ""}
                                            onChange={(e) => {
                                              const endInput = e.target.parentElement.querySelector('input[type="time"]:last-of-type');
                                              if (e.target.value && endInput?.value) {
                                                updateLogTime(goal.id, originalIndex, e.target.value, endInput.value);
                                              }
                                            }}
                                            className="flex-1 px-1 py-0.5 bg-gray-700 text-gray-100 rounded border border-blue-400 focus:outline-none text-[10px]"
                                          />
                                          <span className="text-gray-500 text-[10px]">~</span>
                                          <input
                                            key={`end-${goal.id}-${originalIndex}`}
                                            type="time"
                                            defaultValue={log.endTime || ""}
                                            onChange={(e) => {
                                              const startInput = e.target.parentElement.querySelector('input[type="time"]:first-of-type');
                                              if (startInput?.value && e.target.value) {
                                                updateLogTime(goal.id, originalIndex, startInput.value, e.target.value);
                                              }
                                            }}
                                            className="flex-1 px-1 py-0.5 bg-gray-700 text-gray-100 rounded border border-blue-400 focus:outline-none text-[10px]"
                                          />
                                        </div>
                                        <div
                                          contentEditable
                                          suppressContentEditableWarning
                                          onBlur={(e) => {
                                            updateLogMemo(goal.id, originalIndex, e.currentTarget.textContent);
                                            setEditingLogIndex(null);
                                          }}
                                          onKeyDown={(e) => {
                                            if (e.key === 'Enter') {
                                              e.preventDefault();
                                              e.currentTarget.blur();
                                            } else if (e.key === 'Escape') {
                                              e.preventDefault();
                                              e.currentTarget.textContent = log.memo || "-";
                                              e.currentTarget.blur();
                                              setEditingLogIndex(null);
                                            }
                                          }}
                                          className="text-xs text-gray-100 bg-gray-700 rounded px-1 focus:outline-none focus:border focus:border-blue-400"
                                        >
                                          {log.memo || "-"}
                                        </div>
                                      </div>
                                    ) : (
                                      <div className="mt-0.5 text-xs text-gray-300">
                                        {log.memo || "-"}
                                      </div>
                                    )}
                                  </div>
                                );
                              })}
                            </div>
                            {goal.logs.length > (logShowCounts.get(goal.id) || 6) && !editingLogsGoals.has(goal.id) && (
                              <div className="flex items-center justify-center gap-2 mt-1">
                                <button
                                  onClick={() => toggleExpandedLogs(goal.id)}
                                  className={`text-xs text-gray-400 hover:text-gray-200 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 6 + ((expandedLogsGoals.has(goal.id) || editingLogsGoals.has(goal.id)) ? goal.logs : goal.logs.slice(-(logShowCounts.get(goal.id) || 6))).length ? "ring-2 ring-yellow-400 rounded px-1" : ""}`}
                                >
                                  {expandedLogsGoals.has(goal.id) ? "접기" : "더보기"}
                                </button>
                                {editingLogCount === goal.id ? (
                                  <input
                                    type="number"
                                    min="1"
                                    defaultValue={logShowCounts.get(goal.id) || 6}
                                    autoFocus
                                    onBlur={(e) => {
                                      const val = Math.max(1, parseInt(e.target.value) || 6);
                                      setLogShowCounts(prev => new Map(prev).set(goal.id, val));
                                      setEditingLogCount(null);
                                    }}
                                    onKeyDown={(e) => {
                                      if (e.key === 'Enter') e.target.blur();
                                      if (e.key === 'Escape') { setEditingLogCount(null); }
                                    }}
                                    className="w-12 px-1 py-0.5 bg-gray-700 text-gray-100 rounded text-xs"
                                  />
                                ) : (
                                  <span
                                    onClick={() => setEditingLogCount(goal.id)}
                                    className="text-xs text-gray-500 hover:text-gray-300 cursor-pointer"
                                  >
                                    ({logShowCounts.get(goal.id) || 6})
                                  </span>
                                )}
                              </div>
                            )}
                          </div>
                        )}
                        {goal.logs.length === 0 && (
                          <div>
                            <div className="flex items-center justify-between mb-1">
                              <span className="text-xs text-gray-400">기록 (0)</span>
                              <button
                                onClick={() => setShowAddLog(showAddLog === goal.id ? null : goal.id)}
                                className={`text-xs text-gray-400 hover:text-gray-200 ${sortedGoals.indexOf(goal) === selectedCardIndex && selectedFieldIndex === 5 ? "ring-2 ring-yellow-400 rounded px-1" : ""}`}
                              >
                                + 추가
                              </button>
                            </div>
                          </div>
                        )}
                        {showAddLog === goal.id && (
                          <div className="bg-gray-800/50 rounded p-1.5 mt-2">
                            <div className="flex items-center gap-1.5 flex-wrap">
                              <input
                                type="date"
                                value={newLogDate || new Date().toISOString().split('T')[0]}
                                onChange={(e) => setNewLogDate(e.target.value)}
                                onKeyPress={(e) => handleLogKeyPress(e, goal.id)}
                                className="px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <input
                                type="time"
                                placeholder="시작"
                                value={newLogStartTime}
                                onChange={(e) => setNewLogStartTime(e.target.value)}
                                className="w-24 px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <span className="text-gray-400 text-xs">~</span>
                              <input
                                type="time"
                                placeholder="종료"
                                value={newLogEndTime}
                                onChange={(e) => setNewLogEndTime(e.target.value)}
                                className="w-24 px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <span className="text-gray-400 text-xs">또는</span>
                              <input
                                type="number"
                                placeholder="시간"
                                value={newLogHours}
                                onChange={(e) => setNewLogHours(e.target.value)}
                                onKeyPress={(e) => handleLogKeyPress(e, goal.id)}
                                className="w-12 px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <span className="text-gray-400 text-xs">h</span>
                              <input
                                type="number"
                                placeholder="분"
                                value={newLogMinutes}
                                onChange={(e) => setNewLogMinutes(e.target.value)}
                                onKeyPress={(e) => handleLogKeyPress(e, goal.id)}
                                className="w-12 px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <span className="text-gray-400 text-xs">m</span>
                              <input
                                type="text"
                                placeholder="메모"
                                value={newLogMemo}
                                onChange={(e) => setNewLogMemo(e.target.value)}
                                onKeyPress={(e) => handleLogKeyPress(e, goal.id)}
                                className="flex-1 min-w-[80px] px-1.5 py-0.5 rounded border border-gray-700 bg-gray-700 text-gray-100 focus:outline-none focus:border-blue-400 text-xs"
                              />
                              <button
                                onClick={() => addManualLog(goal.id)}
                                className="px-2 py-0.5 bg-blue-500 hover:bg-blue-400 text-white rounded text-xs transition"
                              >
                                추가
                              </button>
                              <button
                                onClick={() => {
                                  setShowAddLog(null);
                                  setNewLogHours("");
                                  setNewLogMinutes("");
                                  setNewLogDate("");
                                  setNewLogMemo("");
                                  setNewLogStartTime("");
                                  setNewLogEndTime("");
                                }}
                                className="px-2 py-0.5 bg-gray-600 hover:bg-gray-500 text-white rounded text-xs transition"
                              >
                                취소
                              </button>
                            </div>
                          </div>
                        )}
                      </div>
                      {dragOverGoalId === goal.id && draggingGoalId !== goal.id && dragPosition === 'after' && (
                        <div className="h-0.5 bg-blue-400 mt-2" />
                      )}
                    </div>
                    );
                  })}
                  {draggingGoalId && (
                    <div
                      onDragOver={(e) => e.preventDefault()}
                      onDrop={() => {
                        if (draggingGoalId) {
                          setGoals((prevGoals) => {
                            const fromIdx = prevGoals.findIndex((g) => g.id === draggingGoalId);
                            if (fromIdx === -1) return prevGoals;
                            const next = prevGoals.slice();
                            const [moved] = next.splice(fromIdx, 1);
                            next.push(moved);
                            return next;
                          });
                          setDraggingGoalId(null);
                          setDragOverGoalId(null);
                        }
                      }}
                      className="h-8"
                    />
                  )}
                  </>
                )}
              </div>

              {filteredGoals.length > 0 && (
                <div className="mt-3 card-blur rounded-lg p-2.5 mx-2 sm:mx-0">
                  <h3 className="text-sm font-semibold text-white mb-2">전체 통계</h3>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
                    <div className="text-center">
                      <p className="text-gray-400 text-sm">총 투자 시간</p>
                      <p className="text-base font-semibold text-cyan-400">
                        {formatDuration(filteredGoals.reduce((acc, goal) => acc + goal.totalSeconds, 0))}
                      </p>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-400 text-sm">총 목표 시간</p>
                      <p className="text-base font-semibold text-blue-400">
                        {formatHoursVerbose(filteredGoals.reduce((acc, goal) => acc + goal.targetHours, 0))}
                      </p>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-400 text-sm">진행 목표</p>
                      <p className="text-base font-semibold text-green-400">
                        {filteredGoals.filter((goal) => getProgress(goal) >= 100).length}/{filteredGoals.length}
                      </p>
                    </div>
                    <div className="text-center">
                      <p className="text-gray-400 text-sm">평균 진행률</p>
                      <p className="text-base font-semibold text-purple-400">
                        {(filteredGoals.reduce((acc, goal) => acc + getProgress(goal), 0) / filteredGoals.length).toFixed(0)}%
                      </p>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(<GoalTracker />);
    </script>
  </body>
</html>
